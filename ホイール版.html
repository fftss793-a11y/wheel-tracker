
<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3層ホイール＋フルスクリーンログ＋設定（正式名称）</title>
<style>
  :root{
    --stage: 480px;
    --outerR: 175;       /* 操作項目：外半径 */
    --innerR: 85;        /* 操作項目：内半径（描画なし） */
    --lineOuterR: 210;   /* ライン：外半径 */
    --lineInnerR: 185;   /* ライン：内半径 */
    --color-ring: #0f172a;
    --bg: #f6f8fb;
    /* ライン色（IDごと） */
    --A:#1d4ed8; --B:#059669; --C:#d97706; --D:#7c3aed; --E:#dc2626;
    --fab-idle:#1976d2; --fab-on:#ff8f00;
  }
  body{
    margin:0; background:var(--bg);
    font-family: system-ui,"Hiragino Sans","Yu Gothic",sans-serif;
    display:flex; flex-direction:column; align-items:center; gap:12px;
  }
  body.modal-open{ overflow:hidden; } /* モーダル表示中はスクロール禁止 */

  /* Top bar */
  .topbar{ width:min(1000px,95vw); display:flex; justify-content:flex-end; gap:8px; margin-top:8px; }
  .btn{ padding:8px 12px; border:1px solid #0f172a; border-radius:10px; background:#fff; cursor:pointer; font-weight:700; }

  /* Status cards */
  .status{ width:min(1000px,95vw); display:grid; gap:8px; grid-template-columns:repeat(5,1fr); }
  .card{ border:1px solid #e0e4ea; border-radius:10px; background:#fff; box-shadow:0 4px 12px rgba(0,0,0,.08);
         padding:8px 10px; min-height:84px; cursor:pointer; user-select:none; }
  .card.active{ outline:2px solid #409eff; }
  .card h3{ margin:0 6px 6px 0; font-size:14px; display:flex; gap:8px; align-items:center; }
  .task{ font-size:13px; color:#333; }
  .time{ font:12px/1.6 monospace; color:#666; }
  .hint{ font-size:11px; color:#888; margin-left:auto; }
  .badge{ display:inline-block; padding:2px 6px; border-radius:6px; font-size:11px; color:#fff; }
  .A{ background:var(--A); } .B{ background:var(--B); } .C{ background:var(--C); } .D{ background:var(--D); } .E{ background:var(--E); }

  /* Wheel (z-index低めに固定) */
  .wrap{ position:relative; width: var(--stage); height: var(--stage); z-index: 10; }
  svg.wheel{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:420px; height:420px; }
  .ringOuter{ fill:none; stroke:var(--color-ring); stroke-width:3; }
  .spoke{ stroke:var(--color-ring); stroke-width:3; }
  .seg{ fill:#fff; stroke:none; cursor:pointer; transition: fill .1s ease; }
  .seg:hover{ fill:#eef6ff; }
  .segLabel{ pointer-events:none; fill:#222; font-size:12px; text-anchor:middle; dominant-baseline:middle; }

  .lineRing{ opacity:0; pointer-events:none; transition:opacity .12s ease; }
  .lineRing.open{ opacity:1; pointer-events:auto; }
  .lineSeg{ fill:#fff; stroke:none; cursor:pointer; transition:fill .1s ease; }
  .lineSeg:hover{ fill:#f4f4f4; }
  .lineLabel{ pointer-events:none; font-size:11px; text-anchor:middle; dominant-baseline:middle; font-weight:700; }
  .lineGuide{ fill:none; stroke:var(--color-ring); stroke-width:2; opacity:.5; }

  /* Center button */
  .fab{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:100px; height:100px; border-radius:50%;
    border:4px solid var(--A); /* 初期A、JSで更新 */
    display:grid; place-items:center; color:#fff; font-weight:700; cursor:pointer;
    box-shadow:0 12px 28px rgba(0,0,0,.20);
    background:var(--fab-idle); transition:background .2s ease, border-color .2s ease, transform .15s ease;
    z-index:11;
  }
  .fab.tracking{ background:var(--fab-on); }
  .fab:active{ transform:translate(-50%,-50%) scale(0.98); }

  /* Snackbar (Undo) — 最前面 */
  .snackbar{ position:fixed; left:50%; bottom:16px; transform:translateX(-50%);
    background:#333; color:#fff; padding:8px 12px; border-radius:8px; box-shadow:0 8px 22px rgba(0,0,0,.25);
    font-size:13px; display:flex; align-items:center; gap:12px; z-index: 1200; }
  .snackbar.hidden{ display:none; }
  .snackbar button{ background:#fff; color:#333; border:none; border-radius:6px; padding:6px 10px; cursor:pointer; font-weight:700; }

  /* Prompt modal (休憩 / 上限時間) */
  .prompt{ position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center; z-index:1000; }
  .prompt.open{ display:flex; }
  .promptCard{ width:min(560px,90vw); background:#fff; border-radius:12px; box-shadow:0 16px 40px rgba(0,0,0,.35); padding:14px 16px; }
  .promptBtns{ display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }

  /* Settings modal — 前面＆閉じるボタン（×）付き */
  .modal{ position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center; z-index:1000; }
  .modal.open{ display:flex; }
  .modalCard{ width:min(920px,95vw); max-height:90vh; overflow:auto; background:#fff; border-radius:12px; box-shadow:0 16px 40px rgba(0,0,0,.35);
              padding:14px 16px; }
  .modalHeader{ position:sticky; top:0; background:#fff; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #eee; padding-bottom:8px; }
  .modalHeader h2{ margin:0; font-size:16px; }
  .modalBody{ display:grid; gap:12px; grid-template-columns:1fr; margin-top:8px; }
  .lineEditor{ border:1px solid #e0e4ea; border-radius:10px; padding:10px; }
  .lineEditor h3{ margin:0 0 8px; font-size:14px; display:flex; align-items:center; gap:8px; }
  .lineNameInput{ width:100%; padding:6px 8px; border:1px solid #e0e4ea; border-radius:8px; }
  .lineEditor textarea{ width:100%; min-height:64px; font-family:monospace; }
  .modalFooter{ display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }

  /* Fullscreen Log modal */
  .logModal{ position:fixed; inset:0; background:#0b1020d0; display:none; z-index:1100; }
  .logModal.open{ display:block; }
  .logHeader{
    position:sticky; top:0; background:#0b1020; color:#fff; padding:10px 14px; display:flex; align-items:center; gap:12px;
    border-bottom:1px solid #243049;
  }
  .logHeader h2{ margin:0; font-size:16px; }
  .logBody{ height: calc(100vh - 52px); overflow:auto; padding:12px 16px; background:#0b1020; }
  .logRow{ color:#dbe7ff; font-size:13px; display:grid; grid-template-columns: 120px 1fr 1fr; gap:12px; padding:6px 0; border-bottom:1px dashed #243049; }
  .logRow:last-child{ border-bottom:none; }
  .logBadge{ display:inline-block; padding:2px 6px; border-radius:6px; font-size:11px; color:#fff; }
  .logClose{ margin-left:auto; }
  .searchBox{ flex:1; display:flex; }
  .searchBox input{ width:100%; padding:6px 8px; border-radius:8px; border:1px solid #243049; background:#0e1630; color:#dbe7ff; }
</style>
</head>
<body>

<!-- Top bar -->
<div class="topbar">
  <button id="openLogFullscreen" class="btn">ログ（全画面）</button>
  <button id="exportCsv" class="btn">CSV</button>
  <button id="openSettings" class="btn">設定</button>
</div>

<!-- Status cards -->
<div id="status" class="status"></div>

<!-- 3-layer wheel -->
<div class="wrap" role="application" aria-label="3層ホイール">
  <svg id="wheel" class="wheel" viewBox="-210 -210 420 420" aria-hidden="false">
    <!-- 内周（操作項目）ガイド -->
    <circle class="ringOuter" cx="0" cy="0" r="175"/>
    <g id="spokes"></g>
    <g id="segments"></g>

    <!-- 外周（ライン）—右クリックで開閉 -->
    <g id="lineRing" class="lineRing">
      <circle class="lineGuide" cx="0" cy="0" r="210"/>
      <circle class="lineGuide" cx="0" cy="0" r="185"/>
      <g id="lineSegments"></g>
    </g>
  </svg>
  <button class="fab" id="fab" aria-label="終了">START</button>
</div>

<!-- Snackbar (Undo) -->
<div id="snackbar" class="snackbar hidden">
  <span id="snackText">操作を取り消しますか？</span>
  <button id="undoBtn">取り消し</button>
</div>

<!-- Prompt modal（休憩候補／上限確認） -->
<div id="promptModal" class="prompt" aria-modal="true">
  <div class="promptCard">
    <div id="promptText">無操作が続いています。休憩にしますか？</div>
    <div class="promptBtns">
      <button id="promptOk" class="btn">OK</button>
      <button id="promptCancel" class="btn">キャンセル</button>
    </div>
  </div>
</div>

<!-- Settings modal（×／背景クリック／Escで閉じる） -->
<div id="settingsModal" class="modal" aria-modal="true">
  <div class="modalCard">
    <div class="modalHeader">
      <h2>設定（ライン正式名称・操作項目・自動ルール）</h2>
      <div style="display:flex; gap:8px;">
        <button id="closeSettings" class="btn">閉じる</button>
        <button id="closeSettingsX" class="btn" title="閉じる">×</button>
      </div>
    </div>
    <div class="modalBody" id="editors"></div>
    <div class="modalFooter">
      <!-- 自動ルール -->
      <div style="margin-right:auto;">
        <div style="margin-bottom:6px;">
          <label>休憩の無操作候補（分）：
            <input id="idleRestMin" type="number" min="1" max="120" style="width:72px;" />
          </label>
        </div>
        <div style="margin-bottom:6px;">
          <label>最大連続時間の上限（分）：
            <input id="maxSessionMin" type="number" min="10" max="720" style="width:72px;" />
          </label>
          <label style="margin-left:8px;">
            動作：
            <select id="maxSessionAction">
              <option value="stop">自動終了</option>
              <option value="prompt">確認ダイアログ</option>
            </select>
          </label>
        </div>
        <div style="margin-bottom:6px;">
          <label>中央クリック（Idle）の動作：
            <select id="centerIdleAction">
              <option value="none">何もしない</option>
              <option value="resume">直前タスクを再開</option>
              <option value="openLineRing">ラインリングを開く</option>
              <option value="startDefault">既定タスクで開始</option>
            </select>
          </label>
          <label style="margin-left:8px;">再開の閾値（分）：
            <input id="quickResumeMin" type="number" min="1" max="60" style="width:72px;" />
          </label>
        </div>
      </div>
      <button id="importJson" class="btn">JSONインポート</button>
      <button id="exportJson" class="btn">JSONエクスポート</button>
      <button id="resetDefault" class="btn">初期化</button>
      <button id="saveSettings" class="btn">保存</button>
    </div>
  </div>
</div>

<!-- Fullscreen Log modal -->
<div id="logModal" class="logModal" aria-modal="true">
  <div class="logHeader">
    <h2>ログ（全画面プレビュー）</h2>
    <div class="searchBox"><input id="logSearch" type="text" placeholder="検索（タスク名・ライン名・ID）"/></div>
    <button id="logClose" class="btn logClose">閉じる（Esc）</button>
  </div>
  <div id="logBody" class="logBody"></div>
</div>

<script>
/* ====== Utilities ====== */
function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
function fmt(ms){ return new Date(ms).toLocaleString(); }
function dur(a,b){ const sec = Math.max(0, Math.round((b-a)/1000)); if(sec<60) return `${sec}秒`; const m=Math.floor(sec/60), s=sec%60; return s?`${m}分${s}秒`:`${m}分`; }
function elapsedStr(a,b){ const sec=Math.floor((b-a)/1000), h=Math.floor(sec/3600), m=Math.floor((sec%3600)/60), s=sec%60; const pad=x=>String(x).padStart(2,'0'); return h?`${h}:${pad(m)}:${pad(s)}`:`${pad(m)}:${pad(s)}`; }
function annularSector(r1,r2,a0,a1){ const large=(a1-a0)>Math.PI?1:0; const x0o=r2*Math.cos(a0), y0o=r2*Math.sin(a0); const x1o=r2*Math.cos(a1), y1o=r2*Math.sin(a1); const x1i=r1*Math.cos(a1), y1i=r1*Math.sin(a1); const x0i=r1*Math.cos(a0), y0i=r1*Math.sin(a0); return `M ${x0o.toFixed(2)} ${y0o.toFixed(2)} A ${r2} ${r2} 0 ${large} 1 ${x1o.toFixed(2)} ${y1o.toFixed(2)} L ${x1i.toFixed(2)} ${y1i.toFixed(2)} A ${r1} ${r1} 0 ${large} 0 ${x0i.toFixed(2)} ${y0i.toFixed(2)} Z`; }
function uuid(){ return (crypto?.randomUUID?.() || String(Math.random())).toString(); }

/* ====== Constants & State ====== */
const LINES=['A','B','C','D','E'];
const LINE_COLOR={ A:getCSS('--A'), B:getCSS('--B'), C:getCSS('--C'), D:getCSS('--D'), E:getCSS('--E') };

/* 設定：正式名称＆カテゴリ＆自動ルール */
const defaults = {
  lines: {
    A: { name: 'LINE A', categories: ["段取り","投入","検査","調整","記録","休憩"] },
    B: { name: 'LINE B', categories: ["前加工","本加工","検査","再加工","記録","休憩"] },
    C: { name: 'LINE C', categories: ["受入","洗浄","乾燥","検査","記録","休憩"] },
    D: { name: 'LINE D', categories: ["準備","成形","検査","梱包","記録","休憩"] },
    E: { name: 'LINE E', categories: ["搬送","着脱","検査","修整","記録","休憩"] },
  },
  idleRestMin: 15,          // 無操作休憩候補（分）
  maxSessionMin: 480,       // 上限時間（分）
  maxSessionAction: 'stop',  // stop|prompt
  centerIdleAction: 'resume',// none|resume|openLineRing|startDefault
  quickResumeMin: 10         // 直前再開の閾値（分）
};
let config = loadConfig() || structuredClone(defaults);

let currentLine='A';
let categories = (config.lines[currentLine]||defaults.lines[currentLine]).categories;

const outerR=parseFloat(getCSS('--outerR'));
const innerR=parseFloat(getCSS('--innerR'));
const lineOuterR=parseFloat(getCSS('--lineOuterR'));
const lineInnerR=parseFloat(getCSS('--lineInnerR'));

let undoTimer=null;
let lastUndo=null; // {type:'stop'|'autostop', line, log}
let lastInteraction = Date.now();  // 無操作検知用
let idlePromptShown = false;
const maxTimerByLine = { A:null, B:null, C:null, D:null, E:null };

const statusEl=document.getElementById('status');
const wheel=document.getElementById('wheel');
const spokesGroup=document.getElementById('spokes');
const segGroup=document.getElementById('segments');
const lineRing=document.getElementById('lineRing');
const lineSegmentsGroup=document.getElementById('lineSegments');
const fab=document.getElementById('fab');
const snackbar=document.getElementById('snackbar');
const snackText=document.getElementById('snackText');
const undoBtn=document.getElementById('undoBtn');
const promptModal=document.getElementById('promptModal');
const promptText=document.getElementById('promptText');
const promptOk=document.getElementById('promptOk');
const promptCancel=document.getElementById('promptCancel');

const openLogFullscreenBtn=document.getElementById('openLogFullscreen');
const logModal=document.getElementById('logModal');
const logBody=document.getElementById('logBody');
const logCloseBtn=document.getElementById('logClose');
const logSearchInput=document.getElementById('logSearch');

const exportCsvBtn=document.getElementById('exportCsv');
const openSettingsBtn=document.getElementById('openSettings');
const settingsModal=document.getElementById('settingsModal');
const editorsEl=document.getElementById('editors');
const closeSettingsBtn=document.getElementById('closeSettings');
const closeSettingsXBtn=document.getElementById('closeSettingsX');
const importJsonBtn=document.getElementById('importJson');
const exportJsonBtn=document.getElementById('exportJson');
const resetDefaultBtn=document.getElementById('resetDefault');
const saveSettingsBtn=document.getElementById('saveSettings');
const idleRestMinInput=document.getElementById('idleRestMin');
const maxSessionMinInput=document.getElementById('maxSessionMin');
const maxSessionActionInput=document.getElementById('maxSessionAction');
const centerIdleActionInput=document.getElementById('centerIdleAction');
const quickResumeMinInput=document.getElementById('quickResumeMin');

const activeByLine={ A:null,B:null,C:null,D:null,E:null };
let lastEndedByLine = { A:null, B:null, C:null, D:null, E:null };

/* ====== Storage ====== */
function getLogs(line){ try{ return JSON.parse(localStorage.getItem(`timelogs_${line}`)||'[]'); }catch(e){ return []; } }
function saveLogs(line, arr){ localStorage.setItem(`timelogs_${line}`, JSON.stringify(arr)); }
function appendLog(line, log){ const arr=getLogs(line); arr.push(log); saveLogs(line, arr); lastEndedByLine[line] = { task: log.task, endedAt: log.endedAt }; }
function loadConfig(){ try{ return JSON.parse(localStorage.getItem('wheel_config')||'null'); }catch(e){ return null; } }
function saveConfig(c){ localStorage.setItem('wheel_config', JSON.stringify(c)); }

/* ====== Status ====== */
function renderStatus(){
  statusEl.innerHTML='';
  LINES.forEach(line=>{
    const conf = config.lines[line] || defaults.lines[line];
    const name = conf.name || `LINE ${line}`;
    const card=document.createElement('div');
    card.className='card'+(line===currentLine?' active':'');
    card.dataset.line=line;
    const h3=document.createElement('h3');
    h3.innerHTML=`<span class="badge ${line}">${line}</span><strong>${name}</strong><span class="hint">${line===currentLine?'操作対象':''}</span>`;
    const body=document.createElement('div');
    const a=activeByLine[line];
    body.innerHTML=`<div class="task">${a?a.task:'Idle'}</div>
                    <div class="time" id="t_${line}">${a?elapsedStr(a.startedAt,Date.now()):'-'}</div>`;
    card.appendChild(h3); card.appendChild(body);
    card.addEventListener('click',()=>setLine(line));
    statusEl.appendChild(card);
  });
}
setInterval(()=>{
  LINES.forEach(line=>{
    const el=document.getElementById(`t_${line}`); if(!el) return;
    const a=activeByLine[line]; el.textContent=a?elapsedStr(a.startedAt,Date.now()):'-';
  });
},1000);

/* ====== Wheel: Inner (tasks) ====== */
function drawInnerWheel(){
  segGroup.innerHTML=''; spokesGroup.innerHTML='';
  const n=categories.length, offset=-Math.PI/2;
  for(let i=0;i<n;i++){
    const a=offset+(2*Math.PI*i)/n;
    const x1=innerR*Math.cos(a), y1=innerR*Math.sin(a);
    const x2=outerR*Math.cos(a), y2=outerR*Math.sin(a);
    const line=document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('class','spoke');
    line.setAttribute('x1',x1.toFixed(2)); line.setAttribute('y1',y1.toFixed(2));
    line.setAttribute('x2',x2.toFixed(2)); line.setAttribute('y2',y2.toFixed(2));
    spokesGroup.appendChild(line);
  }
  for(let i=0;i<n;i++){
    const a0=offset+(2*Math.PI*i)/n;
    const a1=offset+(2*Math.PI*(i+1))/n;
    const path=document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('class','seg');
    path.setAttribute('d',annularSector(innerR,outerR,a0,a1));
    path.dataset.index=String(i);
    path.addEventListener('click',()=> startTracking(categories[i]));
    segGroup.appendChild(path);
    const rMid=(innerR+outerR)/2, aMid=(a0+a1)/2;
    const lx=rMid*Math.cos(aMid), ly=rMid*Math.sin(aMid);
    const text=document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('class','segLabel');
    text.setAttribute('x',lx.toFixed(2)); text.setAttribute('y',ly.toFixed(2));
    text.textContent=categories[i];
    segGroup.appendChild(text);
  }
}

/* ====== Wheel: Outer (lines) ====== */
function drawLineRing(){
  lineSegmentsGroup.innerHTML='';
  const n=LINES.length, offset=-Math.PI/2;
  for(let i=0;i<n;i++){
    const a0=offset+(2*Math.PI*i)/n;
    const a1=offset+(2*Math.PI*(i+1))/n;
    const path=document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('class','lineSeg');
    path.setAttribute('d',annularSector(lineInnerR,lineOuterR,a0,a1));
    path.dataset.line=LINES[i];
    path.addEventListener('click',()=>{ setLine(LINES[i]); toggleLineRing(false); });
    lineSegmentsGroup.appendChild(path);
    const rMid=(lineInnerR+lineOuterR)/2, aMid=(a0+a1)/2;
    const lx=rMid*Math.cos(aMid), ly=rMid*Math.sin(aMid);
    const lab=document.createElementNS('http://www.w3.org/2000/svg','text');
    lab.setAttribute('class','lineLabel');
    lab.setAttribute('x',lx.toFixed(2)); lab.setAttribute('y',ly.toFixed(2));
    lab.setAttribute('fill', LINE_COLOR[LINES[i]]);
    const name = (config.lines[LINES[i]]||defaults.lines[LINES[i]]).name || LINES[i];
    lab.textContent=name;
    lineSegmentsGroup.appendChild(lab);
  }
}
function toggleLineRing(on){ lineRing.classList.toggle('open', !!on); }

/* ====== Line switch ====== */
function setLine(line){
  if(!LINES.includes(line)) return;
  currentLine=line;
  const conf = config.lines[line] || defaults.lines[line];
  categories = conf.categories;
  drawInnerWheel();
  renderStatus();
  const a=activeByLine[line];
  fab.textContent=a?a.task:'START';
  fab.classList.toggle('tracking', !!a);
  fab.style.borderColor=LINE_COLOR[line];
}

/* ====== Tracking & Auto rules ====== */
function startTracking(task){
  touch();
  if(!task) return;
  const active=activeByLine[currentLine];
  if(active){
    const log={ id:uuid(), task:active.task, startedAt:active.startedAt, endedAt:Date.now() };
    appendLog(currentLine, log);
    showUndo({ type:'autostop', line:currentLine, log });
  }
  activeByLine[currentLine]={ task, startedAt:Date.now() };
  fab.classList.add('tracking'); fab.textContent=task;
  renderStatus();
  // 上限時間タイマー
  resetMaxTimer(currentLine);
  if(config.maxSessionMin && Number(config.maxSessionMin)>0){
    maxTimerByLine[currentLine] = setTimeout(()=>{
      if(config.maxSessionAction==='stop'){
        stopTrackingWithReason('上限時間に達したため自動終了しました');
      }else{
        showPrompt('計測が上限時間に達しました。終了しますか？', ()=> stopTrackingWithReason('上限時間で終了'), ()=>{} );
      }
    }, Number(config.maxSessionMin)*60000);
  }
}
function stopTracking(){
  touch();
  const active=activeByLine[currentLine];
  if(!active) return;
  const log={ id:uuid(), task:active.task, startedAt:active.startedAt, endedAt:Date.now() };
  appendLog(currentLine, log);
  activeByLine[currentLine]=null;
  fab.classList.remove('tracking'); fab.textContent='START';
  renderStatus();
  showUndo({ type:'stop', line:currentLine, log });
  resetMaxTimer(currentLine);
}
function stopTrackingWithReason(msg){
  const active=activeByLine[currentLine];
  if(!active) return;
  const log={ id:uuid(), task:active.task, startedAt:active.startedAt, endedAt:Date.now(), reason: msg };
  appendLog(currentLine, log);
  activeByLine[currentLine]=null;
  fab.classList.remove('tracking'); fab.textContent='START';
  renderStatus();
  showUndo({ type:'stop', line:currentLine, log });
  resetMaxTimer(currentLine);
}
function resetMaxTimer(line){ if(maxTimerByLine[line]){ clearTimeout(maxTimerByLine[line]); maxTimerByLine[line]=null; } }

/* ====== Undo (3s) ====== */
function showUndo(info){
  lastUndo=info;
  snackText.textContent=info.type==='stop' ? '終了を取り消しますか？' : '前タスクの自動終了を取り消しますか？';
  snackbar.classList.remove('hidden');
  clearTimeout(undoTimer);
  undoTimer=setTimeout(()=> snackbar.classList.add('hidden'), 3000);
}
undoBtn.addEventListener('click',()=>{
  if(!lastUndo) return;
  const { type,line,log }=lastUndo;
  const arr=getLogs(line);
  const idx=arr.findIndex(x=>x.id===log.id);
  if(idx>=0){ arr.splice(idx,1); saveLogs(line, arr); }
  // 復帰
  activeByLine[line]={ task:log.task, startedAt:log.startedAt };
  if(line===currentLine){ fab.classList.add('tracking'); fab.textContent=log.task; }
  renderStatus();
  snackbar.classList.add('hidden'); clearTimeout(undoTimer); lastUndo=null;
});

/* ====== Prompt（休憩候補／上限確認） ====== */
function showPrompt(text, onOk, onCancel){
  promptText.textContent = text;
  promptModal.classList.add('open');
  document.body.classList.add('modal-open');
  const ok = ()=>{ promptModal.classList.remove('open'); document.body.classList.remove('modal-open'); onOk?.(); idlePromptShown=false; };
  const cancel = ()=>{ promptModal.classList.remove('open'); document.body.classList.remove('modal-open'); onCancel?.(); idlePromptShown=false; };
  promptOk.onclick = ok;
  promptCancel.onclick = cancel;
}

/* ====== 無操作（Idle）検知 → 休憩候補 ====== */
function touch(){ lastInteraction = Date.now(); }
['click','mousemove','keydown','touchstart','touchmove'].forEach(ev=>{
  document.addEventListener(ev, touch, {passive:true});
});
setInterval(()=>{
  const a = activeByLine[currentLine];
  if(!a) return; // 計測中のみ対象
  const idleMs = Date.now() - lastInteraction;
  const limit = Number(config.idleRestMin || 0) * 60000;
  if(limit>0 && idleMs >= limit && !idlePromptShown){
    idlePromptShown = true;
    showPrompt(`無操作が${Math.round(limit/60000)}分続いています。休憩にしますか？`, ()=>{
      // 現在タスクを終了 → 休憩開始
      const prev = activeByLine[currentLine];
      if(prev){
        const log={ id:uuid(), task:prev.task, startedAt:prev.startedAt, endedAt:Date.now(), reason:'無操作休憩' };
        appendLog(currentLine, log);
      }
      activeByLine[currentLine] = { task:'休憩', startedAt: Date.now() };
      fab.classList.add('tracking'); fab.textContent='休憩';
      renderStatus();
      resetMaxTimer(currentLine);
    }, ()=>{ /* キャンセル */ });
  }
}, 30000); // 30秒ごとに確認

/* ====== Events ====== */
document.querySelector('.wrap').addEventListener('contextmenu',(e)=>{ e.preventDefault(); toggleLineRing(true); });
document.addEventListener('click',(e)=>{
  if(lineRing.classList.contains('open')){
    const within=lineRing.contains(e.target);
    const isRightClick=e.button===2;
    if(!within && !isRightClick) toggleLineRing(false);
  }
});
fab.addEventListener('click',()=>{
  // 計測中は終了
  if(activeByLine[currentLine]) { stopTracking(); return; }
  // Idle時：設定どおりの動作
  const act = String(config.centerIdleAction || 'resume');
  if(act === 'resume'){
    const last = lastEndedByLine[currentLine];
    const limitMs = Number(config.quickResumeMin || 10) * 60000;
    if(last && (Date.now() - last.endedAt) <= limitMs){ startTracking(last.task); }
  } else if(act === 'openLineRing'){
    toggleLineRing(true);
  } else if(act === 'startDefault'){
    const def = (config.lines[currentLine]||defaults.lines[currentLine]).categories[0];
    if(def) startTracking(def);
  } // none：何もしない
});
document.addEventListener('keydown',(e)=>{
  const map={ Digit1:'A',Digit2:'B',Digit3:'C',Digit4:'D',Digit5:'E',
              Numpad1:'A',Numpad2:'B',Numpad3:'C',Numpad4:'D',Numpad5:'E' };
  if(map[e.code]){ setLine(map[e.code]); return; }
  if(e.code==='Space'){ e.preventDefault(); if(activeByLine[currentLine]) stopTracking(); }
  if(e.code==='Escape'){
    toggleLineRing(false);
    // すべてのモーダルを閉じる
    closeSettingsModal();
    closeLog();
    promptModal.classList.remove('open');
    document.body.classList.remove('modal-open');
  }
});

/* ====== Fullscreen Log ====== */
openLogFullscreenBtn.addEventListener('click', ()=> openLog());
logCloseBtn.addEventListener('click', ()=> closeLog());
logSearchInput.addEventListener('input', ()=> renderLogFullscreen(logSearchInput.value.trim()));
function openLog(){ logModal.classList.add('open'); document.body.classList.add('modal-open'); renderLogFullscreen(''); }
function closeLog(){ logModal.classList.remove('open'); document.body.classList.remove('modal-open'); }
function renderLogFullscreen(q){
  let all=[];
  LINES.forEach(line=> {
    const conf = config.lines[line] || defaults.lines[line];
    const name = conf.name;
    all = all.concat(getLogs(line).map(l=>({ ...l, line, lineName: name })));
  });
  all.sort((x,y)=> (y.endedAt||0) - (x.endedAt||0));
  const kw = (q||'').toLowerCase();
  const filt = kw ? all.filter(l=> (String(l.task).toLowerCase().includes(kw) || String(l.line).toLowerCase().includes(kw) || String(l.lineName).toLowerCase().includes(kw)) ) : all;
  logBody.innerHTML='';
  filt.slice(0,1000).forEach(l=>{
    const row=document.createElement('div'); row.className='logRow';
    row.innerHTML = `
      <div><span class="logBadge ${l.line}" style="background:${LINE_COLOR[l.line]}">${l.line}</span> ${escapeHtml(l.lineName||'')}</div>
      <div>${escapeHtml(l.task)}</div>
      <div>${fmt(l.startedAt)} → ${fmt(l.endedAt)}（${dur(l.startedAt,l.endedAt)}）${l.reason? '｜'+escapeHtml(l.reason):''}</div>`;
    logBody.appendChild(row);
  });
}
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

/* ====== CSV Export（lineName列付き） ====== */
exportCsvBtn.addEventListener('click',()=>{
  let all=[]; LINES.forEach(line=> {
    const conf = config.lines[line] || defaults.lines[line];
    const name = conf.name;
    all = all.concat(getLogs(line).map(l=>({...l,line, lineName: name})));
  });
  all.sort((a,b)=> (a.startedAt||0) - (b.startedAt||0));
  const header=['lineId','lineName','task','startedAt','endedAt','startedISO','endedISO','durationSec','reason'];
  const rows=[header.join(',')];
  all.forEach(l=>{
    const durSec = Math.max(0, Math.round((l.endedAt - l.startedAt)/1000));
    rows.push([
      l.line, csvEsc(l.lineName||''), csvEsc(l.task), l.startedAt, l.endedAt,
      csvEsc(new Date(l.startedAt).toISOString()),
      csvEsc(new Date(l.endedAt).toISOString()),
      durSec, csvEsc(l.reason||'')
    ].join(','));
  });
  const csv=rows.join('\n');
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
  const a=document.createElement('a'); const ts=new Date().toISOString().slice(0,10).replace(/-/g,'');
  a.href=URL.createObjectURL(blob); a.download=`timelogs_all_${ts}.csv`;
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
});
function csvEsc(s){ const t=String(s??''); return /[",\n]/.test(t) ? `"${t.replace(/"/g,'""')}"` : t; }

/* ====== Settings（正式名称＋操作項目） ====== */
openSettingsBtn.addEventListener('click',()=> openSettings());
closeSettingsBtn.addEventListener('click',()=> closeSettingsModal());
closeSettingsXBtn.addEventListener('click',()=> closeSettingsModal());
settingsModal.addEventListener('click',(e)=>{ if(e.target===settingsModal) closeSettingsModal(); }); // 背景クリックで閉じる

resetDefaultBtn.addEventListener('click',()=>{
  config = structuredClone(defaults);
  saveConfig(config);
  categories=(config.lines[currentLine]||defaults.lines[currentLine]).categories;
  drawInnerWheel();
  openSettings(); // 再描画
});
exportJsonBtn.addEventListener('click',()=>{
  const blob=new Blob([JSON.stringify(config,null,2)],{type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='wheel_config.json';
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
});
importJsonBtn.addEventListener('click',()=>{
  const inp=document.createElement('input'); inp.type='file'; inp.accept='application/json';
  inp.onchange=()=>{
    const file=inp.files[0]; if(!file) return;
    const reader=new FileReader();
    reader.onload=()=>{
      try{
        const obj=JSON.parse(reader.result);
        // バリデーション：lines.A..E.name（文字列）、categories（配列）
        const ok = LINES.every(k=>{
          const ln = obj?.lines?.[k];
          return ln && typeof ln.name === 'string' && Array.isArray(ln.categories) && ln.categories.length>=1 && ln.categories.length<=12;
        });
        if(!ok) { alert('不正な設定JSON（lines.A..E の name と categories を確認してください）'); return; }
        config = {
          ...defaults,
          ...obj,
          idleRestMin: Number(obj.idleRestMin ?? defaults.idleRestMin),
          maxSessionMin: Number(obj.maxSessionMin ?? defaults.maxSessionMin),
          maxSessionAction: String(obj.maxSessionAction ?? defaults.maxSessionAction),
          centerIdleAction: String(obj.centerIdleAction ?? defaults.centerIdleAction),
          quickResumeMin: Number(obj.quickResumeMin ?? defaults.quickResumeMin)
        };
        saveConfig(config);
        categories=(config.lines[currentLine]||defaults.lines[currentLine]).categories;
        drawInnerWheel(); openSettings();
      }catch(e){ alert('JSONの読み込みに失敗'); }
    };
    reader.readAsText(file);
  };
  inp.click();
});
saveSettingsBtn.addEventListener('click',()=>{
  const newCfg = structuredClone(config);
  // 自動ルール
  newCfg.idleRestMin       = Number(idleRestMinInput.value||defaults.idleRestMin);
  newCfg.maxSessionMin     = Number(maxSessionMinInput.value||defaults.maxSessionMin);
  newCfg.maxSessionAction  = String(maxSessionActionInput.value||defaults.maxSessionAction);
  newCfg.centerIdleAction  = String(centerIdleActionInput.value||defaults.centerIdleAction);
  newCfg.quickResumeMin    = Number(quickResumeMinInput.value||defaults.quickResumeMin);
  // ライン名＆カテゴリ
  LINES.forEach(line=>{
    const nameInput = document.getElementById(`lineName_${line}`);
    const ta = document.getElementById(`ta_${line}`);
    const name = nameInput.value.trim() || `LINE ${line}`;
    const arr = ta.value.split('\n').map(s=>s.trim()).filter(s=>s.length>0);
    newCfg.lines[line] = { name, categories: arr };
  });
  config = newCfg; saveConfig(config);
  categories=(config.lines[currentLine]||defaults.lines[currentLine]).categories;
  drawInnerWheel(); renderStatus();
  closeSettingsModal();
});

function openSettings(){
  editorsEl.innerHTML='';
  LINES.forEach(line=>{
    const conf = config.lines[line] || defaults.lines[line];
    const div=document.createElement('div'); div.className='lineEditor';
    const h=document.createElement('h3'); h.innerHTML=`<span class="badge ${line}">${line}</span> 正式名称`;
    const nameInput = document.createElement('input'); nameInput.id=`lineName_${line}`; nameInput.className='lineNameInput'; nameInput.value = conf.name || `LINE ${line}`;
    const p=document.createElement('p'); p.style.margin='6px 0'; p.textContent='操作項目（1行1項目｜推奨：6〜8）';
    const ta=document.createElement('textarea'); ta.id=`ta_${line}`; ta.value=(conf.categories||[]).join('\n');
    div.appendChild(h); div.appendChild(nameInput); div.appendChild(p); div.appendChild(ta);
    editorsEl.appendChild(div);
  });
  // ルールの現在値
  idleRestMinInput.value      = Number(config.idleRestMin ?? defaults.idleRestMin);
  maxSessionMinInput.value    = Number(config.maxSessionMin ?? defaults.maxSessionMin);
  maxSessionActionInput.value = String(config.maxSessionAction ?? defaults.maxSessionAction);
  centerIdleActionInput.value = String(config.centerIdleAction ?? defaults.centerIdleAction);
  quickResumeMinInput.value   = Number(config.quickResumeMin ?? defaults.quickResumeMin);
  settingsModal.classList.add('open');
  document.body.classList.add('modal-open');
}
function closeSettingsModal(){
  settingsModal.classList.remove('open');
  document.body.classList.remove('modal-open');
}

/* ====== Init ====== */
function init(){
  renderStatus();
  drawInnerWheel();
  drawLineRing();
  setLine('A');
}
init();
</script>
</body>
</html>

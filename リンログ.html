<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
    <title>Production HUD - Wheel Tracker</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet">
    
    <!-- Babel (JSX Converter) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body { font-family: 'Inter', sans-serif; background-color: #020617; color: #f8fafc; }
      .font-mono { font-family: 'JetBrains Mono', monospace; }
      .custom-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
      .custom-scrollbar::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); }
      .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 4px; }
      .no-select { user-select: none; -webkit-user-select: none; }
      .glow-text { text-shadow: 0 0 10px rgba(255,255,255,0.5); }
      
      /* Loading Overlay */
      #loading { position: fixed; inset: 0; background: #020617; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 9999; color: white; transition: opacity 0.5s; }
    </style>
  </head>
  <body class="bg-slate-950 text-slate-50 overflow-hidden">
    
    <div id="loading">
      <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-500 mb-4"></div>
      <div class="text-sm font-mono text-slate-400">LOADING SYSTEM...</div>
    </div>

    <div id="root"></div>

    <!-- MAIN SCRIPT -->
    <script type="text/babel" data-type="module">
      // Import libraries directly from ESM.SH (Reliable CDN)
      import React, { useState, useEffect, useCallback, useRef, useMemo } from 'https://esm.sh/react@18.2.0';
      import ReactDOM from 'https://esm.sh/react-dom@18.2.0/client';
      import * as LucideIcons from 'https://esm.sh/lucide-react@0.263.1';

      // Hide Loading Screen once scripts run
      setTimeout(() => {
        const loader = document.getElementById('loading');
        if(loader) { loader.style.opacity = '0'; setTimeout(()=>loader.remove(), 500); }
      }, 500);

      const { 
        Settings, FileText, Download, LayoutDashboard, Timer, Clock, 
        ArrowLeft, PenTool, Activity, Pencil, LayoutList, X, Search, 
        FileDown, Upload, RotateCcw, Save, Settings2 
      } = LucideIcons;

      /* ================= CONSTANTS ================= */
      const LINES = ['A', 'B', 'C', 'D', 'E'];
      
      const LINE_COLORS = {
        A: '#3b82f6', // Blue
        B: '#10b981', // Emerald
        C: '#f59e0b', // Amber
        D: '#8b5cf6', // Violet
        E: '#ef4444', // Red
      };

      const DEFAULT_CONFIG = {
        lines: {
          A: { name: 'LINE A', categories: ["段取り", "投入", "検査", "調整", "記録", "休憩"] },
          B: { name: 'LINE B', categories: ["前加工", "本加工", "検査", "再加工", "記録", "休憩"] },
          C: { name: 'LINE C', categories: ["受入", "洗浄", "乾燥", "検査", "記録", "休憩"] },
          D: { name: 'LINE D', categories: ["準備", "成形", "検査", "梱包", "記録", "休憩"] },
          E: { name: 'LINE E', categories: ["搬送","着脱","検査","修整","記録","休憩"] },
        },
        idleRestMin: 15,
        maxSessionMin: 480,
        maxSessionAction: 'stop',
        centerIdleAction: 'resume',
        quickResumeMin: 10
      };

      // Geometry (HUD Style)
      const INNER_R = 80;
      const OUTER_R = 210;
      const LINE_INNER_R = 210;
      const LINE_OUTER_R = 280;

      /* ================= UTILS ================= */
      const uuid = () => Math.random().toString(36).substring(2) + Date.now().toString(36);
      
      const formatDuration = (ms) => {
        const sec = Math.max(0, Math.floor(ms / 1000));
        const h = Math.floor(sec / 3600);
        const m = Math.floor((sec % 3600) / 60);
        const s = sec % 60;
        const pad = (n) => String(n).padStart(2, '0');
        if (h > 0) return `${h}:${pad(m)}:${pad(s)}`;
        return `${pad(m)}:${pad(s)}`;
      };

      const formatDateTime = (ms) => new Date(ms).toLocaleString();
      const formatDurationVerbose = (start, end) => {
        const sec = Math.max(0, Math.round((end - start) / 1000));
        if (sec < 60) return `${sec}秒`;
        const m = Math.floor(sec / 60);
        const s = sec % 60;
        return s > 0 ? `${m}分${s}秒` : `${m}分`;
      };

      const annularSector = (r1, r2, a0, a1) => {
        const large = (a1 - a0) > Math.PI ? 1 : 0;
        const x0o = r2 * Math.cos(a0), y0o = r2 * Math.sin(a0);
        const x1o = r2 * Math.cos(a1), y1o = r2 * Math.sin(a1);
        const x1i = r1 * Math.cos(a1), y1i = r1 * Math.sin(a1);
        const x0i = r1 * Math.cos(a0), y0i = r1 * Math.sin(a0);
        return `M ${x0o.toFixed(2)} ${y0o.toFixed(2)} A ${r2} ${r2} 0 ${large} 1 ${x1o.toFixed(2)} ${y1o.toFixed(2)} L ${x1i.toFixed(2)} ${y1i.toFixed(2)} A ${r1} ${r1} 0 ${large} 0 ${x0i.toFixed(2)} ${y0i.toFixed(2)} Z`;
      };

      const getLabelCoords = (r1, r2, a0, a1) => {
        const rMid = (r1 + r2) / 2;
        const aMid = (a0 + a1) / 2;
        return { x: rMid * Math.cos(aMid), y: rMid * Math.sin(aMid) };
      };

      /* ================= COMPONENTS ================= */

      /* --- Wheel Component --- */
      const Wheel = ({ currentLine, categories, lineNames, isTracking, currentTask, activeSessions, isEditMode, onTaskClick, onLineClick, onCenterClick }) => {
        const n = categories.length;
        const offset = -Math.PI / 2;
        const currentColor = LINE_COLORS[currentLine];

        const taskSegments = useMemo(() => {
          return categories.map((cat, i) => {
            const a0 = offset + (2 * Math.PI * i) / n;
            const a1 = offset + (2 * Math.PI * (i + 1)) / n;
            const d = annularSector(INNER_R, OUTER_R, a0, a1);
            const { x, y } = getLabelCoords(INNER_R, OUTER_R, a0, a1);
            const isCurrentTask = !isEditMode && isTracking && currentTask === cat;

            return (
              <g key={i} className={`group ${isEditMode ? 'cursor-not-allowed opacity-40' : 'cursor-pointer'}`} onClick={() => !isEditMode && onTaskClick(cat)}>
                <path d={d} className={`stroke-[1.5px] stroke-slate-900 transition-all duration-200 ${isCurrentTask ? 'fill-slate-800' : 'fill-slate-900/80 hover:fill-slate-800'}`} />
                <text x={x} y={y} className={`pointer-events-none text-[14px] font-bold tracking-wide select-none transition-colors ${isCurrentTask ? 'fill-white glow-text' : 'fill-slate-400 group-hover:fill-slate-200'}`} textAnchor="middle" dominantBaseline="middle">{cat}</text>
              </g>
            );
          });
        }, [categories, n, offset, onTaskClick, currentColor, isTracking, currentTask, isEditMode]);

        const lineSegments = useMemo(() => {
          const ln = LINES.length;
          return LINES.map((line, i) => {
            const a0 = offset + (2 * Math.PI * i) / ln;
            const a1 = offset + (2 * Math.PI * (i + 1)) / ln;
            const isActiveLine = line === currentLine;
            const isRunning = !!activeSessions[line];
            const lineColor = LINE_COLORS[line];
            const rOuter = isActiveLine ? LINE_OUTER_R + 8 : LINE_OUTER_R;
            const d = annularSector(LINE_INNER_R, rOuter, a0, a1);
            const { x, y } = getLabelCoords(LINE_INNER_R, LINE_OUTER_R, a0, a1);
            
            return (
              <g key={line} className="group cursor-pointer" onClick={(e) => { e.stopPropagation(); onLineClick(line); }}>
                <path d={d} className={`stroke-[2px] stroke-slate-950 transition-all duration-300 ${isEditMode ? 'hover:brightness-125' : ''}`} style={{ fill: isEditMode ? '#1e293b' : (isActiveLine ? lineColor : '#1e293b'), fillOpacity: isEditMode ? 1 : (isActiveLine ? 1 : 0.6), stroke: isEditMode ? lineColor : '#020617', strokeDasharray: isEditMode ? '4 2' : 'none' }} />
                <text x={x} y={isActiveLine && !isEditMode ? y - 8 : y} className={`pointer-events-none text-[16px] font-black select-none transition-all ${(isActiveLine && !isEditMode) || isEditMode ? 'fill-white' : 'fill-slate-500 group-hover:fill-slate-300'}`} textAnchor="middle" dominantBaseline="middle" style={(isActiveLine && !isEditMode) ? { textShadow: `0 0 15px ${lineColor}` } : {}}>{lineNames[line]}</text>
                {isEditMode && <g transform={`translate(${x}, ${y + 20})`}><circle r={12} fill={lineColor} /><Pencil size={12} className="text-slate-950 -ml-[6px] -mt-[6px]" /></g>}
                {!isEditMode && isRunning && !isActiveLine && <g transform={`translate(${x}, ${y + 18})`}><circle r={4} fill={lineColor} className="animate-pulse" /></g>}
                {!isEditMode && isActiveLine && <text x={x} y={y + 12} className="pointer-events-none text-[10px] fill-white/90 font-mono tracking-widest uppercase" textAnchor="middle" dominantBaseline="middle">{isRunning ? 'RUNNING' : 'SELECT'}</text>}
              </g>
            );
          });
        }, [lineNames, onLineClick, offset, currentLine, activeSessions, isEditMode]);

        return (
          <div className="relative w-[600px] h-[600px] z-10 mx-auto no-select flex items-center justify-center">
            {/* Background Animations */}
            <div className={`absolute inset-0 rounded-full border transition-all duration-500 ${isEditMode ? 'border-dashed border-blue-500/30 scale-105' : 'border-slate-800/50 scale-95'}`}></div>
            <div className={`absolute inset-0 rounded-full border border-slate-800/30 scale-110 pointer-events-none ${isEditMode ? '' : 'border-dashed animate-[spin_60s_linear_infinite]'}`}></div>
            
            {/* SVG Layer */}
            <svg className={`absolute w-[600px] h-[600px] overflow-visible drop-shadow-[0_0_15px_rgba(0,0,0,0.5)] transition-all duration-300 ${isEditMode ? 'scale-95' : ''}`} viewBox="-300 -300 600 600">
              <g>{taskSegments}</g>
              <g className="origin-center">{lineSegments}</g>
            </svg>
            
            {/* Central Button */}
            <div className="absolute z-20">
              <button onClick={onCenterClick} className={`relative group w-[160px] h-[160px] rounded-full flex items-center justify-center text-white transition-all duration-200 transform overflow-hidden ${isEditMode ? 'bg-slate-800 hover:bg-slate-700 border-4 border-slate-600' : 'active:scale-95'}`} style={!isEditMode ? { boxShadow: isTracking ? `0 0 30px ${currentColor}40, inset 0 0 20px rgba(0,0,0,0.5)` : `0 0 0 4px ${currentColor}, inset 0 0 20px rgba(0,0,0,0.8)` } : {}}>
                <div className={`absolute inset-0 bg-slate-900 ${isEditMode ? 'opacity-100' : ''}`}></div>
                {!isEditMode && (
                  <>
                    {isTracking && <div className="absolute inset-0 opacity-20 animate-[spin_4s_linear_infinite]" style={{ background: `conic-gradient(from 0deg, transparent 0%, ${currentColor} 50%, transparent 100%)` }}></div>}
                    <div className="relative z-10 flex flex-col items-center justify-center">
                      <div className="px-2 py-0.5 rounded text-[10px] font-bold tracking-[0.2em] mb-1" style={{ backgroundColor: isTracking ? currentColor : '#334155', color: isTracking ? '#000' : '#94a3b8' }}>{isTracking ? 'REC' : 'IDLE'}</div>
                      <span className="text-2xl font-black text-center leading-none tracking-tight drop-shadow-md mt-1">{isTracking ? currentTask : 'START'}</span>
                      {!isTracking && <span className="text-[10px] text-slate-500 mt-2 uppercase tracking-wide">Select Task</span>}
                      {isTracking && <Activity className="w-5 h-5 mt-2 animate-pulse text-white/80" />}
                    </div>
                  </>
                )}
                {isEditMode && <div className="relative z-10 flex flex-col items-center justify-center text-slate-300"><span className="text-xl font-black mb-1">EXIT EDIT</span><span className="text-[10px] uppercase tracking-wider text-slate-500">Close Settings</span></div>}
                <div className="absolute inset-0 rounded-full bg-gradient-to-b from-white/10 to-transparent pointer-events-none"></div>
              </button>
            </div>
          </div>
        );
      };

      /* --- Modals --- */
      const PromptModal = ({ isOpen, message, onConfirm, onCancel }) => {
        if (!isOpen) return null;
        return (
          <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-[1300] backdrop-blur-sm animate-in fade-in duration-200">
            <div className="bg-slate-900 border border-slate-700 rounded-xl shadow-2xl p-6 w-[90vw] max-w-[400px]">
              <p className="text-slate-200 text-base mb-6 font-medium">{message}</p>
              <div className="flex justify-end gap-3">
                <button onClick={onCancel} className="px-4 py-2 text-slate-300 bg-slate-800 hover:bg-slate-700 rounded-lg font-bold text-sm transition-colors">キャンセル</button>
                <button onClick={onConfirm} className="px-4 py-2 text-white bg-blue-600 hover:bg-blue-700 rounded-lg font-bold text-sm shadow-lg shadow-blue-900/20 transition-all hover:scale-105">OK</button>
              </div>
            </div>
          </div>
        );
      };

      const LogModal = ({ isOpen, onClose, logs }) => {
        const [query, setQuery] = useState('');
        if (!isOpen) return null;
        const filteredLogs = logs.filter(l => {
          const q = query.toLowerCase();
          return (l.task.toLowerCase().includes(q) || l.line.toLowerCase().includes(q) || l.lineName.toLowerCase().includes(q) || (l.reason && l.reason.toLowerCase().includes(q)));
        }).sort((a, b) => b.endedAt - a.endedAt).slice(0, 500);

        return (
          <div className="fixed inset-0 bg-[#020617]/95 backdrop-blur-md z-[1200] flex flex-col text-slate-200 animate-in fade-in slide-in-from-bottom-4 duration-300">
            <div className="flex items-center gap-4 p-4 border-b border-slate-800 bg-[#0f152a]">
              <h2 className="text-lg font-bold text-white shrink-0 flex items-center gap-2"><FileDown className="w-5 h-5 text-blue-400" />ログ履歴</h2>
              <div className="flex-1 relative max-w-md ml-auto">
                <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-slate-500" />
                <input type="text" placeholder="検索 (タスク, ライン, ID...)" value={query} onChange={e => setQuery(e.target.value)} className="w-full bg-[#1a2238] border border-slate-700 rounded-lg py-2 pl-9 pr-4 text-sm text-slate-100 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-all" />
              </div>
              <button onClick={onClose} className="p-2 hover:bg-slate-800 rounded-lg shrink-0 text-slate-400 hover:text-white transition-colors"><X className="w-6 h-6" /></button>
            </div>
            <div className="flex-1 overflow-y-auto p-4 custom-scrollbar">
              <div className="max-w-5xl mx-auto grid gap-2">
                {filteredLogs.map(log => (
                  <div key={log.id} className="grid grid-cols-[100px_1fr] md:grid-cols-[120px_1fr_1fr] gap-x-4 gap-y-1 p-3 rounded-lg border border-slate-800 bg-slate-900/50 hover:bg-slate-800/50 hover:border-slate-700 transition-all text-xs md:text-sm">
                    <div className="flex items-center">
                      <span className="px-2 py-0.5 rounded text-[10px] md:text-xs font-bold text-slate-950 mr-2 shadow-[0_0_10px_-3px_currentColor]" style={{ backgroundColor: LINE_COLORS[log.line], color: '#000' }}>{log.line}</span>
                      <span className="truncate opacity-80 font-mono text-xs">{log.lineName}</span>
                    </div>
                    <div className="font-bold text-white tracking-wide">{log.task}</div>
                    <div className="col-span-2 md:col-span-1 text-slate-400 font-mono text-xs flex items-center gap-2 justify-end">
                      {formatDateTime(log.startedAt)} <span className="opacity-30">→</span> {formatDateTime(log.endedAt)}
                      <span className="ml-3 text-blue-300 font-bold">({formatDurationVerbose(log.startedAt, log.endedAt)})</span>
                      {log.reason && <span className="ml-2 text-amber-500 text-[10px] border border-amber-500/30 px-1.5 py-0.5 rounded bg-amber-500/10">{log.reason}</span>}
                    </div>
                  </div>
                ))}
                {filteredLogs.length === 0 && <div className="text-center py-20 text-slate-600 font-mono">NO LOGS FOUND</div>}
              </div>
            </div>
          </div>
        );
      };

      const LineSettingsModal = ({ isOpen, onClose, lineId, config, onSave }) => {
        const [name, setName] = useState('');
        const [cats, setCats] = useState('');
        useEffect(() => {
          if (isOpen && config.lines[lineId]) {
            setName(config.lines[lineId].name);
            setCats(config.lines[lineId].categories.join('\n'));
          }
        }, [isOpen, lineId, config]);
        if (!isOpen) return null;

        return (
          <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-[1300] backdrop-blur-sm animate-in zoom-in-95 duration-200" onClick={onClose}>
            <div className="bg-slate-900 border border-slate-700 rounded-xl shadow-2xl w-[90vw] max-w-[480px] overflow-hidden" onClick={e => e.stopPropagation()}>
              <div className="flex items-center justify-between p-4 border-b border-slate-800 bg-slate-950">
                <div className="flex items-center gap-3">
                  <span className="flex items-center justify-center w-8 h-8 rounded font-black text-slate-950 shadow-[0_0_15px_-3px_currentColor]" style={{ backgroundColor: LINE_COLORS[lineId] }}>{lineId}</span>
                  <h2 className="text-lg font-bold text-white">ライン設定</h2>
                </div>
                <button onClick={onClose}><X className="text-slate-500 hover:text-white transition-colors" /></button>
              </div>
              <div className="p-6 flex flex-col gap-6">
                <label className="flex flex-col gap-2">
                  <span className="text-xs font-bold text-slate-400 uppercase tracking-wider">ライン正式名称</span>
                  <input type="text" value={name} onChange={e => setName(e.target.value)} className="bg-slate-800 border border-slate-700 rounded-lg p-3 text-white font-bold focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-all" />
                </label>
                <label className="flex flex-col gap-2">
                  <div className="flex justify-between items-center"><span className="text-xs font-bold text-slate-400 uppercase tracking-wider">タスク項目 (改行区切り)</span></div>
                  <textarea value={cats} onChange={e => setCats(e.target.value)} className="bg-slate-800 border border-slate-700 rounded-lg p-3 text-sm text-slate-200 font-mono h-[200px] focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-all resize-none custom-scrollbar" placeholder="段取り&#13;&#10;加工..." />
                </label>
              </div>
              <div className="p-4 bg-slate-950 border-t border-slate-800 flex justify-end gap-3">
                <button onClick={onClose} className="px-4 py-2 text-slate-400 hover:text-white font-bold text-sm transition-colors">キャンセル</button>
                <button onClick={() => { onSave(lineId, name, cats.split('\n').map(s => s.trim()).filter(s => s.length > 0)); }} className="flex items-center gap-2 px-6 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg font-bold shadow-lg shadow-blue-900/30 transition-all hover:scale-105"><Save size={16} /> 保存</button>
              </div>
            </div>
          </div>
        );
      };

      const GlobalSettingsModal = ({ isOpen, onClose, config, onSave, onReset }) => {
        const [localConfig, setLocalConfig] = useState(config);
        useEffect(() => { if (isOpen) setLocalConfig(JSON.parse(JSON.stringify(config))); }, [isOpen, config]);
        if (!isOpen) return null;
        
        const handleImport = (e) => {
            const file = e.target.files?.[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => { try { const obj = JSON.parse(reader.result); if (obj.lines) { setLocalConfig(prev => ({ ...prev, ...obj })); alert('読み込みました (保存で適用)'); } } catch { alert('エラー'); } };
            reader.readAsText(file);
        };
        const handleExport = () => {
            const blob = new Blob([JSON.stringify(localConfig, null, 2)], { type: 'application/json' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'config.json'; document.body.appendChild(a); a.click(); document.body.removeChild(a);
        };

        return (
          <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-[1300] backdrop-blur-sm animate-in zoom-in-95 duration-200" onClick={onClose}>
            <div className="bg-slate-900 border border-slate-700 rounded-xl shadow-2xl w-[95vw] max-w-[600px] max-h-[90vh] flex flex-col" onClick={e => e.stopPropagation()}>
              <div className="flex items-center justify-between p-4 border-b border-slate-800 bg-slate-950">
                <h2 className="text-lg font-bold text-white flex items-center gap-2"><Settings2 className="w-5 h-5 text-slate-400" />システム全体設定</h2>
                <button onClick={onClose}><X className="text-slate-500 hover:text-white transition-colors" /></button>
              </div>
              <div className="flex-1 overflow-y-auto p-6 custom-scrollbar flex flex-col gap-6">
                <section>
                  <h3 className="text-xs font-bold text-blue-400 uppercase tracking-wider mb-4 border-b border-slate-800 pb-2">自動化ルール (タイマー)</h3>
                  <div className="grid gap-4">
                    <label className="flex items-center justify-between group"><span className="text-slate-300 text-sm font-medium">無操作休憩の提案 (分)</span><input type="number" min="1" max="120" value={localConfig.idleRestMin} onChange={e => setLocalConfig({...localConfig, idleRestMin: Number(e.target.value)})} className="w-20 bg-slate-800 border border-slate-700 rounded p-2 text-right text-white" /></label>
                    <label className="flex items-center justify-between group"><span className="text-slate-300 text-sm font-medium">最大連続時間の上限 (分)</span><div className="flex gap-2"><input type="number" min="10" max="720" value={localConfig.maxSessionMin} onChange={e => setLocalConfig({...localConfig, maxSessionMin: Number(e.target.value)})} className="w-20 bg-slate-800 border border-slate-700 rounded p-2 text-right text-white" /><select value={localConfig.maxSessionAction} onChange={e => setLocalConfig({...localConfig, maxSessionAction: e.target.value})} className="bg-slate-800 border border-slate-700 rounded p-2 text-white text-sm"><option value="stop">自動終了</option><option value="prompt">確認</option></select></div></label>
                  </div>
                </section>
                <section>
                    <h3 className="text-xs font-bold text-blue-400 uppercase tracking-wider mb-4 border-b border-slate-800 pb-2">データ管理</h3>
                    <div className="grid grid-cols-3 gap-3">
                        <button onClick={handleExport} className="flex flex-col items-center gap-2 p-3 bg-slate-800 rounded-lg border border-slate-700"><FileDown size={20} className="text-slate-400" /><span className="text-xs font-bold text-slate-300">設定書出</span></button>
                        <label className="flex flex-col items-center gap-2 p-3 bg-slate-800 rounded-lg border border-slate-700 cursor-pointer"><Upload size={20} className="text-slate-400" /><span className="text-xs font-bold text-slate-300">設定取込</span><input type="file" accept=".json" className="hidden" onChange={handleImport} /></label>
                        <button onClick={() => { if(confirm('設定を初期化しますか？')) onReset(); }} className="flex flex-col items-center gap-2 p-3 bg-slate-800 rounded-lg border border-slate-700"><RotateCcw size={20} className="text-red-500" /><span className="text-xs font-bold text-red-400">初期化</span></button>
                    </div>
                </section>
              </div>
              <div className="p-4 bg-slate-950 border-t border-slate-800 flex justify-end gap-3">
                <button onClick={onClose} className="px-4 py-2 text-slate-400 hover:text-white font-bold text-sm">キャンセル</button>
                <button onClick={() => onSave(localConfig)} className="flex items-center gap-2 px-6 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg font-bold"><Save size={16} /> 保存</button>
              </div>
            </div>
          </div>
        );
      };

      /* ================= MAIN APP ================= */
      const App = () => {
        const [config, setConfig] = useState(DEFAULT_CONFIG);
        const [currentLine, setCurrentLine] = useState('A');
        const [activeSessions, setActiveSessions] = useState({ A: null, B: null, C: null, D: null, E: null });
        const [lastEnded, setLastEnded] = useState({ A: null, B: null, C: null, D: null, E: null });
        const [now, setNow] = useState(Date.now());
        const [undoInfo, setUndoInfo] = useState(null);
        const [isEditMode, setIsEditMode] = useState(false);
        const [promptState, setPromptState] = useState({ isOpen: false, message: '', onConfirm: () => {}, onCancel: () => {} });
        const [isLogOpen, setIsLogOpen] = useState(false);
        const [editingLine, setEditingLine] = useState(null);
        const [isGlobalSettingsOpen, setIsGlobalSettingsOpen] = useState(false);
        const undoTimerRef = useRef(null);
        const lastInteractionRef = useRef(Date.now());
        const maxSessionTimerRef = useRef(null);
        const idlePromptShownRef = useRef(false);

        useEffect(() => {
          try {
            const saved = localStorage.getItem('wheel_config_v2');
            if (saved) setConfig({ ...DEFAULT_CONFIG, ...JSON.parse(saved) });
          } catch (e) {}
        }, []);
        useEffect(() => { const timer = setInterval(() => setNow(Date.now()), 1000); return () => clearInterval(timer); }, []);
        useEffect(() => { localStorage.setItem('wheel_config_v2', JSON.stringify(config)); }, [config]);

        const getLogs = (line) => { try { return JSON.parse(localStorage.getItem(`timelogs_v2_${line}`) || '[]'); } catch { return []; } };
        const getAllLogs = () => LINES.flatMap(line => getLogs(line));
        const saveLog = (line, log) => {
          const logs = getLogs(line); logs.push(log);
          localStorage.setItem(`timelogs_v2_${line}`, JSON.stringify(logs));
          setLastEnded(prev => ({ ...prev, [line]: { task: log.task, endedAt: log.endedAt } }));
        };
        const removeLog = (line, logId) => {
            const logs = getLogs(line);
            localStorage.setItem(`timelogs_v2_${line}`, JSON.stringify(logs.filter(l => l.id !== logId)));
        };

        const touch = useCallback(() => { lastInteractionRef.current = Date.now(); }, []);
        useEffect(() => {
          const events = ['click', 'mousemove', 'keydown', 'touchstart', 'touchmove'];
          events.forEach(ev => window.addEventListener(ev, touch, { passive: true }));
          return () => events.forEach(ev => window.removeEventListener(ev, touch));
        }, [touch]);

        useEffect(() => {
          const checkIdle = setInterval(() => {
            const currentSession = activeSessions[currentLine];
            if (!currentSession) return;
            const idleMs = Date.now() - lastInteractionRef.current;
            const limitMs = (config.idleRestMin || 15) * 60000;
            if (limitMs > 0 && idleMs >= limitMs && !idlePromptShownRef.current) {
              idlePromptShownRef.current = true;
              setPromptState({
                isOpen: true,
                message: `無操作が${Math.round(limitMs / 60000)}分続いています。休憩にしますか？`,
                onConfirm: () => { stopTracking(currentLine, '無操作休憩'); startTracking(currentLine, '休憩'); setPromptState(p=>({...p,isOpen:false})); idlePromptShownRef.current = false; touch(); },
                onCancel: () => { setPromptState(p=>({...p,isOpen:false})); idlePromptShownRef.current = false; touch(); }
              });
            }
          }, 10000);
          return () => clearInterval(checkIdle);
        }, [activeSessions, currentLine, config.idleRestMin, touch]);

        const resetMaxTimer = useCallback((line) => {
            if (maxSessionTimerRef.current) clearTimeout(maxSessionTimerRef.current);
            if (line !== currentLine) return;
            if (config.maxSessionMin > 0) {
                maxSessionTimerRef.current = setTimeout(() => {
                    if (config.maxSessionAction === 'stop') { stopTracking(line, '上限時間により自動終了'); }
                    else {
                        setPromptState({ isOpen: true, message: '計測が上限時間に達しました。終了しますか？', onConfirm: () => { stopTracking(line, '上限時間により終了'); setPromptState(p=>({...p,isOpen:false})); }, onCancel: () => setPromptState(p=>({...p,isOpen:false})) });
                    }
                }, config.maxSessionMin * 60000);
            }
        }, [config.maxSessionMin, config.maxSessionAction, currentLine]);

        const startTracking = (line, task) => {
            touch();
            const active = activeSessions[line];
            if (active) {
                const log = { id: uuid(), line, lineName: config.lines[line].name, task: active.task, startedAt: active.startedAt, endedAt: Date.now() };
                saveLog(line, log);
                showUndo({ type: 'autostop', line, log });
            }
            setActiveSessions(prev => ({ ...prev, [line]: { task, startedAt: Date.now() } }));
            resetMaxTimer(line);
        };
        const stopTracking = (line, reason) => {
            touch();
            const active = activeSessions[line];
            if (!active) return;
            const log = { id: uuid(), line, lineName: config.lines[line].name, task: active.task, startedAt: active.startedAt, endedAt: Date.now(), reason };
            saveLog(line, log);
            setActiveSessions(prev => ({ ...prev, [line]: null }));
            showUndo({ type: 'stop', line, log });
            if (maxSessionTimerRef.current) clearTimeout(maxSessionTimerRef.current);
        };
        const showUndo = (info) => {
            setUndoInfo(info);
            if (undoTimerRef.current) clearTimeout(undoTimerRef.current);
            undoTimerRef.current = setTimeout(() => setUndoInfo(null), 3000);
        };
        const handleUndo = () => {
            if (!undoInfo) return;
            const { line, log } = undoInfo;
            removeLog(line, log.id);
            setActiveSessions(prev => ({ ...prev, [line]: { task: log.task, startedAt: log.startedAt } }));
            setUndoInfo(null);
            resetMaxTimer(line);
        };
        const handleCsvExport = () => {
            const all = getAllLogs().sort((a, b) => a.startedAt - b.startedAt);
            const header = ['lineId', 'lineName', 'task', 'startedAt', 'endedAt', 'startedISO', 'endedISO', 'durationSec', 'reason'];
            const rows = all.map(l => {
                const dur = Math.round((l.endedAt - l.startedAt) / 1000);
                const esc = (s) => `"${String(s || '').replace(/"/g, '""')}"`;
                return [l.line, esc(l.lineName), esc(l.task), l.startedAt, l.endedAt, esc(new Date(l.startedAt).toISOString()), esc(new Date(l.endedAt).toISOString()), dur, esc(l.reason)].join(',');
            });
            const blob = new Blob([[header.join(','), ...rows].join('\n')], { type: 'text/csv;charset=utf-8;' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `timelogs_${new Date().toISOString().slice(0, 10)}.csv`; document.body.appendChild(a); a.click(); document.body.removeChild(a);
        };

        const handleWheelTaskClick = (task) => { if (!isEditMode) startTracking(currentLine, task); };
        const handleWheelLineClick = (line) => { if (isEditMode) setEditingLine(line); else setCurrentLine(line); };
        const handleCenterClick = () => {
            touch();
            if (isEditMode) { setIsEditMode(false); return; }
            if (activeSessions[currentLine]) { stopTracking(currentLine); return; }
            const action = config.centerIdleAction;
            if (action === 'resume') {
                const last = lastEnded[currentLine];
                if (last && (Date.now() - last.endedAt) <= (config.quickResumeMin || 10) * 60000) startTracking(currentLine, last.task);
            } else if (action === 'startDefault') {
                const def = config.lines[currentLine].categories[0];
                if (def) startTracking(currentLine, def);
            }
        };

        useEffect(() => {
            const handleKey = (e) => {
                if (e.code === 'Space') { e.preventDefault(); if (!isEditMode && activeSessions[currentLine]) stopTracking(currentLine); }
                if (!isEditMode && e.key >= '1' && e.key <= '5') { const map = ['A','B','C','D','E']; const idx = parseInt(e.key) - 1; if (map[idx]) setCurrentLine(map[idx]); }
                if (e.code === 'Escape') { setIsLogOpen(false); setEditingLine(null); setIsGlobalSettingsOpen(false); if(isEditMode) setIsEditMode(false); }
            };
            window.addEventListener('keydown', handleKey); return () => window.removeEventListener('keydown', handleKey);
        }, [currentLine, activeSessions, isEditMode]);

        const lineConf = config.lines[currentLine];
        const currentSession = activeSessions[currentLine];
        const currentColor = LINE_COLORS[currentLine];

        return (
          <div className={`min-h-screen flex flex-col items-center justify-between p-6 relative overflow-hidden bg-slate-950 transition-colors duration-500 ${isEditMode ? 'ring-8 ring-inset ring-blue-500/20' : ''}`}>
            <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[800px] h-[800px] rounded-full opacity-10 blur-[100px] pointer-events-none transition-colors duration-1000" style={{ backgroundColor: currentColor }} />
            {isEditMode && <div className="absolute inset-0 bg-[linear-gradient(rgba(59,130,246,0.1)_1px,transparent_1px),linear-gradient(90deg,rgba(59,130,246,0.1)_1px,transparent_1px)] bg-[size:40px_40px] pointer-events-none z-0"></div>}
            
            <header className="w-full max-w-[1200px] flex justify-between items-start z-30">
              <div className="flex flex-col">
                <div className="flex items-center gap-2 text-slate-100">{isEditMode ? <PenTool className="w-6 h-6 text-blue-400" /> : <LayoutDashboard className="w-6 h-6 text-slate-400" />}<h1 className="text-xl font-bold tracking-tight">{isEditMode ? 'EDIT MODE' : 'PRODUCTION HUD'}</h1></div>
                <p className="text-slate-500 text-xs font-mono mt-1 ml-8">{isEditMode ? 'CLICK ELEMENT TO CONFIGURE' : `SYSTEM READY // ${new Date(now).toLocaleTimeString()}`}</p>
              </div>
              <div className="flex gap-3">
                <button onClick={() => setIsLogOpen(true)} className="p-3 bg-slate-900/50 backdrop-blur rounded-lg border border-slate-800 text-slate-400 hover:text-white hover:border-slate-600 transition-all"><FileText className="w-5 h-5" /></button>
                <button onClick={handleCsvExport} className="p-3 bg-slate-900/50 backdrop-blur rounded-lg border border-slate-800 text-slate-400 hover:text-white hover:border-slate-600 transition-all"><Download className="w-5 h-5" /></button>
                <button onClick={() => setIsEditMode(!isEditMode)} className={`p-3 backdrop-blur rounded-lg border transition-all ${isEditMode ? 'bg-blue-600 border-blue-500 text-white shadow-[0_0_15px_rgba(37,99,235,0.5)]' : 'bg-slate-900/50 border-slate-800 text-slate-400 hover:text-white hover:border-slate-600'}`}><Settings className={`w-5 h-5 ${isEditMode ? 'animate-spin' : ''}`} /></button>
              </div>
            </header>

            <main className="flex-1 flex flex-col items-center justify-center w-full relative z-20 scale-90 sm:scale-100 xl:scale-110 transition-transform">
              {isEditMode && <div className="absolute -top-10 text-blue-400 text-sm font-bold animate-bounce uppercase tracking-widest">Click Ring to Edit Line</div>}
              <Wheel currentLine={currentLine} categories={lineConf.categories} lineNames={Object.fromEntries(LINES.map(l => [l, config.lines[l].name]))} isTracking={!!currentSession} currentTask={currentSession?.task || ''} activeSessions={activeSessions} isEditMode={isEditMode} onTaskClick={handleWheelTaskClick} onLineClick={handleWheelLineClick} onCenterClick={handleCenterClick} />
            </main>

            <div className={`w-full max-w-[500px] z-30 mb-8 transition-all duration-300 ${isEditMode ? 'cursor-pointer hover:scale-105' : ''}`} onClick={() => isEditMode && setIsGlobalSettingsOpen(true)}>
              <div className={`bg-slate-900/80 backdrop-blur-md border rounded-2xl p-6 shadow-2xl relative overflow-hidden ${isEditMode ? 'border-blue-500/50 border-dashed' : 'border-slate-800'}`}>
                {isEditMode && <div className="absolute inset-0 flex items-center justify-center bg-black/40 text-blue-400 font-black text-xl tracking-widest z-50">EDIT GLOBAL SETTINGS</div>}
                <div className="absolute top-0 left-0 w-1 h-full transition-colors duration-300" style={{ backgroundColor: currentColor }}></div>
                <div className="flex items-center justify-between">
                  <div><div className="text-slate-400 text-xs font-bold tracking-wider uppercase mb-1">Current Line</div><div className="text-2xl font-black text-white flex items-center gap-3"><span className="px-2 py-0.5 rounded text-sm font-bold text-slate-950" style={{ backgroundColor: currentColor }}>{currentLine}</span>{config.lines[currentLine].name}</div></div>
                  <div className="text-right"><div className="text-slate-400 text-xs font-bold tracking-wider uppercase mb-1">Elapsed Time</div><div className="text-3xl font-mono font-medium text-white tabular-nums tracking-tight flex items-center justify-end gap-2">{currentSession ? <><span className="animate-pulse text-red-500 text-xs">●</span>{formatDuration(now - currentSession.startedAt)}</> : <span className="text-slate-600">--:--:--</span>}</div></div>
                </div>
                <div className="mt-6 pt-6 border-t border-slate-800 flex items-center gap-4">
                  <div className="p-3 rounded-lg bg-slate-950 border border-slate-800 text-slate-300"><Clock className="w-6 h-6" /></div>
                  <div className="flex-1"><div className="text-slate-500 text-xs uppercase font-bold tracking-wider">Current Activity</div><div className={`text-lg font-semibold truncate ${currentSession ? 'text-white' : 'text-slate-600'}`}>{currentSession ? currentSession.task : 'System Idle'}</div></div>
                </div>
              </div>
            </div>

            {undoInfo && (
              <div className="fixed bottom-8 left-1/2 -translate-x-1/2 bg-slate-800 border border-slate-700 text-white pl-5 pr-3 py-3 rounded-full shadow-2xl flex items-center gap-6 z-[1200] animate-in slide-in-from-bottom-5 fade-in duration-300">
                <span className="text-sm font-medium tracking-wide">{undoInfo.type === 'stop' ? 'Task Stopped' : 'Auto Switched'}</span>
                <button onClick={handleUndo} className="bg-slate-100 text-slate-900 px-4 py-1.5 rounded-full text-xs font-bold hover:bg-white transition-colors">UNDO</button>
              </div>
            )}

            <PromptModal isOpen={promptState.isOpen} message={promptState.message} onConfirm={promptState.onConfirm} onCancel={promptState.onCancel} />
            <LogModal isOpen={isLogOpen} onClose={() => setIsLogOpen(false)} logs={getAllLogs()} />
            {editingLine && <LineSettingsModal isOpen={true} onClose={() => setEditingLine(null)} lineId={editingLine} config={config} onSave={(lineId, newName, newCats) => { setConfig(prev => ({ ...prev, lines: { ...prev.lines, [lineId]: { name: newName, categories: newCats } } })); setEditingLine(null); }} />}
            <GlobalSettingsModal isOpen={isGlobalSettingsOpen} onClose={() => setIsGlobalSettingsOpen(false)} config={config} onSave={(newConf) => { setConfig(newConf); setIsGlobalSettingsOpen(false); }} onReset={() => { setConfig(DEFAULT_CONFIG); setIsGlobalSettingsOpen(false); }} />
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>
<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3å±¤ãƒ›ã‚¤ãƒ¼ãƒ«ï¼‹ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ­ã‚°ï¼‹è¨­å®šï¼ˆæ­£å¼åç§°ï¼‰</title>
  <style>
    :root {
      --stage: 480px;
      --outerR: 175;
      --innerR: 85;
      --lineOuterR: 210;
      --lineInnerR: 185;
      /* Blue-White Theme */
      --primary: #1e40af;
      --primary-light: #3b82f6;
      --primary-dark: #1e3a8a;
      --accent: #0ea5e9;
      --color-ring: #1e40af;
      --bg: #f0f9ff;
      --bg-white: #ffffff;
      --text: #1e293b;
      --text-light: #64748b;
      --border: #bfdbfe;
      /* ãƒ©ã‚¤ãƒ³è‰²ï¼ˆã™ã¹ã¦é’ç³»çµ±ï¼‰ */
      --A: #1e40af;
      --B: #2563eb;
      --C: #3b82f6;
      --D: #0284c7;
      --E: #0ea5e9;
      --fab-idle: #1e40af;
      --fab-on: #0ea5e9;
    }

    body {
      margin: 0;
      background: var(--bg);
      font-family: system-ui, "Hiragino Sans", "Yu Gothic", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    body.modal-open {
      overflow: hidden;
    }

    /* Header with line tabs */
    .header {
      width: 100%;
      background: var(--primary);
      padding: 12px 0;
      box-shadow: 0 4px 16px rgba(30, 64, 175, 0.2);
    }

    .header-inner {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header-title {
      color: white;
      font-size: 1.2rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .header-actions {
      display: flex;
      gap: 8px;
    }

    .btn {
      padding: 8px 16px;
      border: 2px solid white;
      border-radius: 8px;
      background: transparent;
      color: white;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      transition: all 0.2s ease;
    }

    .btn:hover {
      background: white;
      color: var(--primary);
    }

    /* Line tabs (horizontal selector at top) */
    .line-tabs {
      width: 100%;
      background: var(--bg-white);
      border-bottom: 2px solid var(--border);
      display: flex;
      justify-content: center;
      gap: 4px;
      padding: 8px 16px;
    }

    .line-tab {
      padding: 12px 24px;
      border: none;
      background: transparent;
      color: var(--text-light);
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      border-radius: 8px 8px 0 0;
      transition: all 0.2s ease;
      border-bottom: 3px solid transparent;
    }

    .line-tab:hover {
      background: var(--bg);
      color: var(--primary);
    }

    .line-tab.active {
      color: var(--primary);
      background: var(--bg);
      border-bottom: 3px solid var(--primary);
    }

    .line-tab .tab-status {
      font-size: 0.75rem;
      color: var(--text-light);
      margin-left: 8px;
    }

    .line-tab.active .tab-status {
      color: var(--accent);
    }

    /* Main content area */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      width: 100%;
      max-width: 600px;
    }

    /* Current status display */
    .current-status {
      text-align: center;
      margin-bottom: 20px;
    }

    .current-line-name {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--primary);
      margin-bottom: 4px;
    }

    .current-task {
      font-size: 1.1rem;
      color: var(--text-light);
    }

    .current-time {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--primary-light);
      font-family: monospace;
    }

    /* Hide old status cards - replaced by tabs */
    .status {
      display: none;
    }

    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 11px;
      color: #fff;
    }

    .A {
      background: var(--A);
    }

    .B {
      background: var(--B);
    }

    .C {
      background: var(--C);
    }

    .D {
      background: var(--D);
    }

    .E {
      background: var(--E);
    }

    /* Wheel (z-indexä½ã‚ã«å›ºå®š) */
    .wrap {
      position: relative;
      width: var(--stage);
      height: var(--stage);
      z-index: 10;
    }

    svg.wheel {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 420px;
      height: 420px;
    }

    .ringOuter {
      fill: none;
      stroke: var(--color-ring);
      stroke-width: 3;
    }

    .spoke {
      stroke: var(--color-ring);
      stroke-width: 3;
    }

    .seg {
      fill: #fff;
      stroke: none;
      cursor: pointer;
      transition: fill .1s ease;
    }

    .seg:hover {
      fill: #eef6ff;
    }

    .segLabel {
      pointer-events: none;
      fill: #222;
      font-size: 12px;
      text-anchor: middle;
      dominant-baseline: middle;
    }

    .lineRing {
      opacity: 0;
      pointer-events: none;
      transition: opacity .12s ease;
    }

    .lineRing.open {
      opacity: 1;
      pointer-events: auto;
    }

    .lineSeg {
      fill: #fff;
      stroke: none;
      cursor: pointer;
      transition: fill .1s ease;
    }

    .lineSeg:hover {
      fill: #f4f4f4;
    }

    .lineLabel {
      pointer-events: none;
      font-size: 11px;
      text-anchor: middle;
      dominant-baseline: middle;
      font-weight: 700;
    }

    .lineGuide {
      fill: none;
      stroke: var(--color-ring);
      stroke-width: 2;
      opacity: .5;
    }

    /* Center button */
    .fab {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 100px;
      height: 100px;
      border-radius: 50%;
      border: 4px solid var(--A);
      /* åˆæœŸAã€JSã§æ›´æ–° */
      display: grid;
      place-items: center;
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 12px 28px rgba(0, 0, 0, .20);
      background: var(--fab-idle);
      transition: background .2s ease, border-color .2s ease, transform .15s ease;
      z-index: 11;
    }

    .fab.tracking {
      background: var(--fab-on);
    }

    .fab:active {
      transform: translate(-50%, -50%) scale(0.98);
    }

    /* Sub-menu popup for hierarchical selection */
    .sub-menu {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.35);
      z-index: 100;
      min-width: 180px;
      text-align: center;
    }

    .sub-menu.hidden {
      display: none;
    }

    .sub-menu-title {
      font-weight: 700;
      font-size: 16px;
      margin-bottom: 12px;
      color: #333;
    }

    .sub-menu-items {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sub-menu-item {
      padding: 12px 20px;
      background: #f3f4f6;
      border: none;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s ease, transform 0.1s ease;
    }

    .sub-menu-item:hover {
      background: #e0e7ff;
    }

    .sub-menu-item:active {
      transform: scale(0.98);
    }

    .sub-menu-cancel {
      margin-top: 12px;
      padding: 8px 16px;
      background: #ef4444;
      color: #fff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    /* Snackbar (Undo) â€” æœ€å‰é¢ */
    .snackbar {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 8px 22px rgba(0, 0, 0, .25);
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 1200;
    }

    .snackbar.hidden {
      display: none;
    }

    .snackbar button {
      background: #fff;
      color: #333;
      border: none;
      border-radius: 6px;
      padding: 6px 10px;
      cursor: pointer;
      font-weight: 700;
    }

    /* Prompt modal (ä¼‘æ†© / ä¸Šé™æ™‚é–“) */
    .prompt {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .prompt.open {
      display: flex;
    }

    .promptCard {
      width: min(560px, 90vw);
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 16px 40px rgba(0, 0, 0, .35);
      padding: 14px 16px;
    }

    .promptBtns {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 12px;
    }

    /* Settings modal â€” å‰é¢ï¼†é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ï¼ˆÃ—ï¼‰ä»˜ã */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal.open {
      display: flex;
    }

    .modalCard {
      width: min(920px, 95vw);
      max-height: 90vh;
      overflow: auto;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 16px 40px rgba(0, 0, 0, .35);
      padding: 14px 16px;
    }

    .modalHeader {
      position: sticky;
      top: 0;
      background: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #eee;
      padding-bottom: 8px;
    }

    .modalHeader h2 {
      margin: 0;
      font-size: 16px;
    }

    .modalBody {
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
      margin-top: 8px;
    }

    .lineEditor {
      border: 1px solid #e0e4ea;
      border-radius: 10px;
      padding: 10px;
    }

    .lineEditor h3 {
      margin: 0 0 8px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .lineNameInput {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #e0e4ea;
      border-radius: 8px;
    }

    .lineEditor textarea {
      width: 100%;
      min-height: 64px;
      font-family: monospace;
    }

    .modalFooter {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 12px;
    }

    /* Fullscreen Log modal */
    .logModal {
      position: fixed;
      inset: 0;
      background: #0b1020d0;
      display: none;
      z-index: 1100;
    }

    .logModal.open {
      display: block;
    }

    .logHeader {
      position: sticky;
      top: 0;
      background: #0b1020;
      color: #fff;
      padding: 10px 14px;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid #243049;
    }

    .logHeader h2 {
      margin: 0;
      font-size: 16px;
    }

    .logBody {
      height: calc(100vh - 52px);
      overflow: auto;
      padding: 12px 16px;
      background: #0b1020;
    }

    .logRow {
      color: #dbe7ff;
      font-size: 13px;
      display: grid;
      grid-template-columns: 120px 1fr 1fr;
      gap: 12px;
      padding: 6px 0;
      border-bottom: 1px dashed #243049;
    }

    .logRow:last-child {
      border-bottom: none;
    }

    .logBadge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 11px;
      color: #fff;
    }

    .logClose {
      margin-left: auto;
    }

    .searchBox {
      flex: 1;
      display: flex;
    }

    .searchBox input {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #243049;
      background: #0e1630;
      color: #dbe7ff;
    }
  </style>
</head>

<body>

  <!-- Header with actions -->
  <header class="header">
    <div class="header-inner">
      <div class="header-title">
        â±ï¸ ã‚¿ã‚¤ãƒ ãƒ­ã‚¬ãƒ¼
      </div>
      <div class="header-actions">
        <button id="openLogFullscreen" class="btn">ğŸ“‹ ãƒ­ã‚°</button>
        <button id="exportCsv" class="btn">ğŸ“¥ CSV</button>
        <button id="openSettings" class="btn">âš™ï¸ è¨­å®š</button>
      </div>
    </div>
  </header>

  <!-- Line tabs (horizontal selector) -->
  <div class="line-tabs" id="lineTabs">
    <!-- Populated by JS -->
  </div>

  <!-- Current status display -->
  <div class="current-status" id="currentStatus">
    <div class="current-line-name" id="currentLineName">ãƒ©ã‚¤ãƒ³1</div>
    <div class="current-task" id="currentTask">å¾…æ©Ÿä¸­</div>
    <div class="current-time" id="currentTime">--:--</div>
  </div>

  <!-- Hidden old status container for compatibility -->
  <div id="status" class="status"></div>

  <!-- 3-layer wheel -->
  <div class="wrap" role="application" aria-label="3å±¤ãƒ›ã‚¤ãƒ¼ãƒ«">
    <svg id="wheel" class="wheel" viewBox="-210 -210 420 420" aria-hidden="false">
      <circle class="ringOuter" cx="0" cy="0" r="175" />
      <g id="spokes"></g>
      <g id="segments"></g>

      <!-- Outer ring for line selection (hidden by default, right-click to show) -->
      <g id="lineRing" class="lineRing">
        <circle class="lineGuide" cx="0" cy="0" r="210" />
        <circle class="lineGuide" cx="0" cy="0" r="185" />
        <g id="lineSegments"></g>
      </g>
    </svg>
    <button class="fab" id="fab" aria-label="çµ‚äº†">START</button>
    <!-- Sub-menu popup for categories with sub-items -->
    <div id="subMenu" class="sub-menu hidden">
      <div class="sub-menu-title" id="subMenuTitle">åœæ­¢</div>
      <div class="sub-menu-items" id="subMenuItems"></div>
      <button class="sub-menu-cancel" id="subMenuCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
    </div>
  </div>

  <!-- Snackbar (Undo) -->
  <div id="snackbar" class="snackbar hidden">
    <span id="snackText">æ“ä½œã‚’å–ã‚Šæ¶ˆã—ã¾ã™ã‹ï¼Ÿ</span>
    <button id="undoBtn">å–ã‚Šæ¶ˆã—</button>
  </div>

  <!-- Prompt modalï¼ˆä¼‘æ†©å€™è£œï¼ä¸Šé™ç¢ºèªï¼‰ -->
  <div id="promptModal" class="prompt" aria-modal="true">
    <div class="promptCard">
      <div id="promptText">ç„¡æ“ä½œãŒç¶šã„ã¦ã„ã¾ã™ã€‚ä¼‘æ†©ã«ã—ã¾ã™ã‹ï¼Ÿ</div>
      <div class="promptBtns">
        <button id="promptOk" class="btn">OK</button>
        <button id="promptCancel" class="btn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
      </div>
    </div>
  </div>

  <!-- Settings modalï¼ˆÃ—ï¼èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ï¼Escã§é–‰ã˜ã‚‹ï¼‰ -->
  <div id="settingsModal" class="modal" aria-modal="true">
    <div class="modalCard">
      <div class="modalHeader">
        <h2>è¨­å®šï¼ˆãƒ©ã‚¤ãƒ³æ­£å¼åç§°ãƒ»æ“ä½œé …ç›®ãƒ»è‡ªå‹•ãƒ«ãƒ¼ãƒ«ï¼‰</h2>
        <div style="display:flex; gap:8px;">
          <button id="closeSettings" class="btn">é–‰ã˜ã‚‹</button>
          <button id="closeSettingsX" class="btn" title="é–‰ã˜ã‚‹">Ã—</button>
        </div>
      </div>
      <div class="modalBody" id="editors"></div>
      <div class="modalFooter">
        <!-- è‡ªå‹•ãƒ«ãƒ¼ãƒ« -->
        <div style="margin-right:auto;">
          <div style="margin-bottom:6px;">
            <label>ä¼‘æ†©ã®ç„¡æ“ä½œå€™è£œï¼ˆåˆ†ï¼‰ï¼š
              <input id="idleRestMin" type="number" min="1" max="120" style="width:72px;" />
            </label>
          </div>
          <div style="margin-bottom:6px;">
            <label>æœ€å¤§é€£ç¶šæ™‚é–“ã®ä¸Šé™ï¼ˆåˆ†ï¼‰ï¼š
              <input id="maxSessionMin" type="number" min="10" max="720" style="width:72px;" />
            </label>
            <label style="margin-left:8px;">
              å‹•ä½œï¼š
              <select id="maxSessionAction">
                <option value="stop">è‡ªå‹•çµ‚äº†</option>
                <option value="prompt">ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°</option>
              </select>
            </label>
          </div>
          <div style="margin-bottom:6px;">
            <label>ä¸­å¤®ã‚¯ãƒªãƒƒã‚¯ï¼ˆIdleï¼‰ã®å‹•ä½œï¼š
              <select id="centerIdleAction">
                <option value="none">ä½•ã‚‚ã—ãªã„</option>
                <option value="resume">ç›´å‰ã‚¿ã‚¹ã‚¯ã‚’å†é–‹</option>
                <option value="openLineRing">ãƒ©ã‚¤ãƒ³ãƒªãƒ³ã‚°ã‚’é–‹ã</option>
                <option value="startDefault">æ—¢å®šã‚¿ã‚¹ã‚¯ã§é–‹å§‹</option>
              </select>
            </label>
            <label style="margin-left:8px;">å†é–‹ã®é–¾å€¤ï¼ˆåˆ†ï¼‰ï¼š
              <input id="quickResumeMin" type="number" min="1" max="60" style="width:72px;" />
            </label>
          </div>
        </div>
        <button id="importJson" class="btn">JSONã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
        <button id="exportJson" class="btn">JSONã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
        <button id="resetDefault" class="btn">åˆæœŸåŒ–</button>
        <button id="saveSettings" class="btn">ä¿å­˜</button>
      </div>
    </div>
  </div>

  <!-- Fullscreen Log modal -->
  <div id="logModal" class="logModal" aria-modal="true">
    <div class="logHeader">
      <h2>ãƒ­ã‚°ï¼ˆå…¨ç”»é¢ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰</h2>
      <div class="searchBox"><input id="logSearch" type="text" placeholder="æ¤œç´¢ï¼ˆã‚¿ã‚¹ã‚¯åãƒ»ãƒ©ã‚¤ãƒ³åãƒ»IDï¼‰" /></div>
      <button id="logClose" class="btn logClose">é–‰ã˜ã‚‹ï¼ˆEscï¼‰</button>
    </div>
    <div id="logBody" class="logBody"></div>
  </div>

  <script>
    /* ====== Utilities ====== */
    function getCSS(v) { return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
    function fmt(ms) { return new Date(ms).toLocaleString(); }
    function dur(a, b) { const sec = Math.max(0, Math.round((b - a) / 1000)); if (sec < 60) return `${sec}ç§’`; const m = Math.floor(sec / 60), s = sec % 60; return s ? `${m}åˆ†${s}ç§’` : `${m}åˆ†`; }
    function elapsedStr(a, b) { const sec = Math.floor((b - a) / 1000), h = Math.floor(sec / 3600), m = Math.floor((sec % 3600) / 60), s = sec % 60; const pad = x => String(x).padStart(2, '0'); return h ? `${h}:${pad(m)}:${pad(s)}` : `${pad(m)}:${pad(s)}`; }
    function annularSector(r1, r2, a0, a1) { const large = (a1 - a0) > Math.PI ? 1 : 0; const x0o = r2 * Math.cos(a0), y0o = r2 * Math.sin(a0); const x1o = r2 * Math.cos(a1), y1o = r2 * Math.sin(a1); const x1i = r1 * Math.cos(a1), y1i = r1 * Math.sin(a1); const x0i = r1 * Math.cos(a0), y0i = r1 * Math.sin(a0); return `M ${x0o.toFixed(2)} ${y0o.toFixed(2)} A ${r2} ${r2} 0 ${large} 1 ${x1o.toFixed(2)} ${y1o.toFixed(2)} L ${x1i.toFixed(2)} ${y1i.toFixed(2)} A ${r1} ${r1} 0 ${large} 0 ${x0i.toFixed(2)} ${y0i.toFixed(2)} Z`; }
    function uuid() { return (crypto?.randomUUID?.() || String(Math.random())).toString(); }

    /* ====== Constants & State ====== */
    const LINES = ['A', 'B', 'C', 'D', 'E'];
    const LINE_COLOR = { A: getCSS('--A'), B: getCSS('--B'), C: getCSS('--C'), D: getCSS('--D'), E: getCSS('--E') };

    /* è¨­å®šï¼šæ­£å¼åç§°ï¼†ã‚«ãƒ†ã‚´ãƒªï¼†è‡ªå‹•ãƒ«ãƒ¼ãƒ« */
    const defaults = {
      lines: {
        A: {
          name: 'ãƒ©ã‚¤ãƒ³1', categories: [
            { name: 'ç«‹ã¡ä¸Šã’', sub: [] },
            { name: 'ç¨¼åƒ', sub: [] },
            { name: 'Lotåˆ‡æ›¿', sub: [] },
            { name: 'åœæ­¢', sub: ['ãƒˆãƒ©ãƒ–ãƒ«', 'è¨ˆç”»åœæ­¢', 'å¾…æ©Ÿ'] },
            { name: 'ç«‹ã¡ä¸‹ã’', sub: [] }
          ]
        },
        B: {
          name: 'ãƒ©ã‚¤ãƒ³2', categories: [
            { name: 'ç«‹ã¡ä¸Šã’', sub: [] },
            { name: 'ç¨¼åƒ', sub: [] },
            { name: 'Lotåˆ‡æ›¿', sub: [] },
            { name: 'åœæ­¢', sub: ['ãƒˆãƒ©ãƒ–ãƒ«', 'è¨ˆç”»åœæ­¢', 'å¾…æ©Ÿ'] },
            { name: 'ç«‹ã¡ä¸‹ã’', sub: [] }
          ]
        },
        C: {
          name: 'ãƒ©ã‚¤ãƒ³3', categories: [
            { name: 'ç«‹ã¡ä¸Šã’', sub: [] },
            { name: 'ç¨¼åƒ', sub: [] },
            { name: 'Lotåˆ‡æ›¿', sub: [] },
            { name: 'åœæ­¢', sub: ['ãƒˆãƒ©ãƒ–ãƒ«', 'è¨ˆç”»åœæ­¢', 'å¾…æ©Ÿ'] },
            { name: 'ç«‹ã¡ä¸‹ã’', sub: [] }
          ]
        },
        D: {
          name: 'ãƒ©ã‚¤ãƒ³4', categories: [
            { name: 'ç«‹ã¡ä¸Šã’', sub: [] },
            { name: 'ç¨¼åƒ', sub: [] },
            { name: 'Lotåˆ‡æ›¿', sub: [] },
            { name: 'åœæ­¢', sub: ['ãƒˆãƒ©ãƒ–ãƒ«', 'è¨ˆç”»åœæ­¢', 'å¾…æ©Ÿ'] },
            { name: 'ç«‹ã¡ä¸‹ã’', sub: [] }
          ]
        },
        E: {
          name: 'ãƒ©ã‚¤ãƒ³5', categories: [
            { name: 'ç«‹ã¡ä¸Šã’', sub: [] },
            { name: 'ç¨¼åƒ', sub: [] },
            { name: 'Lotåˆ‡æ›¿', sub: [] },
            { name: 'åœæ­¢', sub: ['ãƒˆãƒ©ãƒ–ãƒ«', 'è¨ˆç”»åœæ­¢', 'å¾…æ©Ÿ'] },
            { name: 'ç«‹ã¡ä¸‹ã’', sub: [] }
          ]
        },
      },
      idleRestMin: 15,          // ç„¡æ“ä½œä¼‘æ†©å€™è£œï¼ˆåˆ†ï¼‰
      maxSessionMin: 480,       // ä¸Šé™æ™‚é–“ï¼ˆåˆ†ï¼‰
      maxSessionAction: 'stop',  // stop|prompt
      centerIdleAction: 'resume',// none|resume|openLineRing|startDefault
      quickResumeMin: 10         // ç›´å‰å†é–‹ã®é–¾å€¤ï¼ˆåˆ†ï¼‰
    };
    let config = loadConfig() || structuredClone(defaults);

    let currentLine = 'A';
    let categories = (config.lines[currentLine] || defaults.lines[currentLine]).categories;

    const outerR = parseFloat(getCSS('--outerR'));
    const innerR = parseFloat(getCSS('--innerR'));
    const lineOuterR = parseFloat(getCSS('--lineOuterR'));
    const lineInnerR = parseFloat(getCSS('--lineInnerR'));

    let undoTimer = null;
    let lastUndo = null; // {type:'stop'|'autostop', line, log}
    let lastInteraction = Date.now();  // ç„¡æ“ä½œæ¤œçŸ¥ç”¨
    let idlePromptShown = false;
    const maxTimerByLine = { A: null, B: null, C: null, D: null, E: null };

    const statusEl = document.getElementById('status');
    const wheel = document.getElementById('wheel');
    const spokesGroup = document.getElementById('spokes');
    const segGroup = document.getElementById('segments');
    const lineRing = document.getElementById('lineRing');
    const lineSegmentsGroup = document.getElementById('lineSegments');
    const fab = document.getElementById('fab');
    const snackbar = document.getElementById('snackbar');
    const snackText = document.getElementById('snackText');
    const undoBtn = document.getElementById('undoBtn');
    const promptModal = document.getElementById('promptModal');
    const promptText = document.getElementById('promptText');
    const promptOk = document.getElementById('promptOk');
    const promptCancel = document.getElementById('promptCancel');

    const openLogFullscreenBtn = document.getElementById('openLogFullscreen');
    const logModal = document.getElementById('logModal');
    const logBody = document.getElementById('logBody');
    const logCloseBtn = document.getElementById('logClose');
    const logSearchInput = document.getElementById('logSearch');

    const exportCsvBtn = document.getElementById('exportCsv');
    const openSettingsBtn = document.getElementById('openSettings');
    const settingsModal = document.getElementById('settingsModal');
    const editorsEl = document.getElementById('editors');
    const closeSettingsBtn = document.getElementById('closeSettings');
    const closeSettingsXBtn = document.getElementById('closeSettingsX');
    const importJsonBtn = document.getElementById('importJson');
    const exportJsonBtn = document.getElementById('exportJson');
    const resetDefaultBtn = document.getElementById('resetDefault');
    const saveSettingsBtn = document.getElementById('saveSettings');
    const idleRestMinInput = document.getElementById('idleRestMin');
    const maxSessionMinInput = document.getElementById('maxSessionMin');
    const maxSessionActionInput = document.getElementById('maxSessionAction');
    const centerIdleActionInput = document.getElementById('centerIdleAction');
    const quickResumeMinInput = document.getElementById('quickResumeMin');

    const activeByLine = { A: null, B: null, C: null, D: null, E: null };
    let lastEndedByLine = { A: null, B: null, C: null, D: null, E: null };

    /* ====== Storage ====== */
    function getLogs(line) { try { return JSON.parse(localStorage.getItem(`timelogs_${line}`) || '[]'); } catch (e) { return []; } }
    function saveLogs(line, arr) { localStorage.setItem(`timelogs_${line}`, JSON.stringify(arr)); }
    function appendLog(line, log) { const arr = getLogs(line); arr.push(log); saveLogs(line, arr); lastEndedByLine[line] = { task: log.task, endedAt: log.endedAt }; }
    function loadConfig() { try { return JSON.parse(localStorage.getItem('wheel_config') || 'null'); } catch (e) { return null; } }
    function saveConfig(c) { localStorage.setItem('wheel_config', JSON.stringify(c)); }

    /* ====== Status - Line Tabs (horizontal selector at top) ====== */
    const lineTabsEl = document.getElementById('lineTabs');
    const currentLineNameEl = document.getElementById('currentLineName');
    const currentTaskEl = document.getElementById('currentTask');
    const currentTimeEl = document.getElementById('currentTime');

    function renderLineTabs() {
      lineTabsEl.innerHTML = '';
      LINES.forEach(line => {
        const conf = config.lines[line] || defaults.lines[line];
        const name = conf.name || `ãƒ©ã‚¤ãƒ³${line}`;
        const a = activeByLine[line];
        const tab = document.createElement('button');
        tab.className = 'line-tab' + (line === currentLine ? ' active' : '');
        tab.innerHTML = `${name}<span class="tab-status">${a ? 'â—' : ''}</span>`;
        tab.addEventListener('click', () => setLine(line));
        lineTabsEl.appendChild(tab);
      });
    }

    function updateCurrentStatus() {
      const conf = config.lines[currentLine] || defaults.lines[currentLine];
      const name = conf.name || `ãƒ©ã‚¤ãƒ³${currentLine}`;
      const a = activeByLine[currentLine];
      currentLineNameEl.textContent = name;
      currentTaskEl.textContent = a ? a.task : 'å¾…æ©Ÿä¸­';
      currentTimeEl.textContent = a ? elapsedStr(a.startedAt, Date.now()) : '--:--';
    }

    // Keep old renderStatus for compatibility (hidden by CSS)
    function renderStatus() {
      statusEl.innerHTML = '';
      LINES.forEach(line => {
        const conf = config.lines[line] || defaults.lines[line];
        const name = conf.name || `LINE ${line}`;
        const card = document.createElement('div');
        card.className = 'card' + (line === currentLine ? ' active' : '');
        card.dataset.line = line;
        const h3 = document.createElement('h3');
        h3.innerHTML = `<span class="badge ${line}">${line}</span><strong>${name}</strong><span class="hint">${line === currentLine ? 'æ“ä½œå¯¾è±¡' : ''}</span>`;
        const body = document.createElement('div');
        const a = activeByLine[line];
        body.innerHTML = `<div class="task">${a ? a.task : 'Idle'}</div>
                    <div class="time" id="t_${line}">${a ? elapsedStr(a.startedAt, Date.now()) : '-'}</div>`;
        card.appendChild(h3); card.appendChild(body);
        card.addEventListener('click', () => setLine(line));
        statusEl.appendChild(card);
      });
      // Also update line tabs and current status
      renderLineTabs();
      updateCurrentStatus();
    }

    setInterval(() => {
      updateCurrentStatus(); // Update current status timer
      LINES.forEach(line => {
        const el = document.getElementById(`t_${line}`); if (!el) return;
        const a = activeByLine[line]; el.textContent = a ? elapsedStr(a.startedAt, Date.now()) : '-';
      });
    }, 1000);

    /* ====== Wheel: Inner (tasks) ====== */
    // Helper to get category name (handles both string and object format)
    function getCategoryName(cat) {
      return typeof cat === 'object' ? cat.name : cat;
    }
    function getCategorySub(cat) {
      return typeof cat === 'object' ? (cat.sub || []) : [];
    }

    // Sub-menu elements
    const subMenu = document.getElementById('subMenu');
    const subMenuTitle = document.getElementById('subMenuTitle');
    const subMenuItems = document.getElementById('subMenuItems');
    const subMenuCancel = document.getElementById('subMenuCancel');

    function showSubMenu(categoryName, subItems) {
      subMenuTitle.textContent = categoryName;
      subMenuItems.innerHTML = '';
      subItems.forEach(item => {
        const btn = document.createElement('button');
        btn.className = 'sub-menu-item';
        btn.textContent = item;
        btn.addEventListener('click', () => {
          hideSubMenu();
          startTracking(`${categoryName} (${item})`);
        });
        subMenuItems.appendChild(btn);
      });
      subMenu.classList.remove('hidden');
    }
    function hideSubMenu() {
      subMenu.classList.add('hidden');
    }
    subMenuCancel.addEventListener('click', hideSubMenu);

    function handleCategoryClick(cat) {
      const name = getCategoryName(cat);
      const subs = getCategorySub(cat);
      if (subs.length > 0) {
        showSubMenu(name, subs);
      } else {
        startTracking(name);
      }
    }

    function drawInnerWheel() {
      segGroup.innerHTML = ''; spokesGroup.innerHTML = '';
      const n = categories.length, offset = -Math.PI / 2;
      for (let i = 0; i < n; i++) {
        const a = offset + (2 * Math.PI * i) / n;
        const x1 = innerR * Math.cos(a), y1 = innerR * Math.sin(a);
        const x2 = outerR * Math.cos(a), y2 = outerR * Math.sin(a);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('class', 'spoke');
        line.setAttribute('x1', x1.toFixed(2)); line.setAttribute('y1', y1.toFixed(2));
        line.setAttribute('x2', x2.toFixed(2)); line.setAttribute('y2', y2.toFixed(2));
        spokesGroup.appendChild(line);
      }
      for (let i = 0; i < n; i++) {
        const a0 = offset + (2 * Math.PI * i) / n;
        const a1 = offset + (2 * Math.PI * (i + 1)) / n;
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('class', 'seg');
        path.setAttribute('d', annularSector(innerR, outerR, a0, a1));
        path.dataset.index = String(i);
        const cat = categories[i];
        path.addEventListener('click', () => handleCategoryClick(cat));
        segGroup.appendChild(path);
        const rMid = (innerR + outerR) / 2, aMid = (a0 + a1) / 2;
        const lx = rMid * Math.cos(aMid), ly = rMid * Math.sin(aMid);
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('class', 'segLabel');
        text.setAttribute('x', lx.toFixed(2)); text.setAttribute('y', ly.toFixed(2));
        text.textContent = getCategoryName(cat);
        segGroup.appendChild(text);
      }
    }

    /* ====== Wheel: Outer (lines) ====== */
    function drawLineRing() {
      lineSegmentsGroup.innerHTML = '';
      const n = LINES.length, offset = -Math.PI / 2;
      for (let i = 0; i < n; i++) {
        const a0 = offset + (2 * Math.PI * i) / n;
        const a1 = offset + (2 * Math.PI * (i + 1)) / n;
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('class', 'lineSeg');
        path.setAttribute('d', annularSector(lineInnerR, lineOuterR, a0, a1));
        path.dataset.line = LINES[i];
        path.addEventListener('click', () => { setLine(LINES[i]); toggleLineRing(false); });
        lineSegmentsGroup.appendChild(path);
        const rMid = (lineInnerR + lineOuterR) / 2, aMid = (a0 + a1) / 2;
        const lx = rMid * Math.cos(aMid), ly = rMid * Math.sin(aMid);
        const lab = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        lab.setAttribute('class', 'lineLabel');
        lab.setAttribute('x', lx.toFixed(2)); lab.setAttribute('y', ly.toFixed(2));
        lab.setAttribute('fill', LINE_COLOR[LINES[i]]);
        const name = (config.lines[LINES[i]] || defaults.lines[LINES[i]]).name || LINES[i];
        lab.textContent = name;
        lineSegmentsGroup.appendChild(lab);
      }
    }
    function toggleLineRing(on) { lineRing.classList.toggle('open', !!on); }

    /* ====== Line switch ====== */
    function setLine(line) {
      if (!LINES.includes(line)) return;
      currentLine = line;
      const conf = config.lines[line] || defaults.lines[line];
      categories = conf.categories;
      drawInnerWheel();
      renderStatus();
      const a = activeByLine[line];
      fab.textContent = a ? a.task : 'START';
      fab.classList.toggle('tracking', !!a);
      fab.style.borderColor = LINE_COLOR[line];
    }

    /* ====== Tracking & Auto rules ====== */
    function startTracking(task) {
      touch();
      if (!task) return;
      const active = activeByLine[currentLine];
      if (active) {
        const log = { id: uuid(), task: active.task, startedAt: active.startedAt, endedAt: Date.now() };
        appendLog(currentLine, log);
        showUndo({ type: 'autostop', line: currentLine, log });
      }
      activeByLine[currentLine] = { task, startedAt: Date.now() };
      fab.classList.add('tracking'); fab.textContent = task;
      renderStatus();
      // ä¸Šé™æ™‚é–“ã‚¿ã‚¤ãƒãƒ¼
      resetMaxTimer(currentLine);
      if (config.maxSessionMin && Number(config.maxSessionMin) > 0) {
        maxTimerByLine[currentLine] = setTimeout(() => {
          if (config.maxSessionAction === 'stop') {
            stopTrackingWithReason('ä¸Šé™æ™‚é–“ã«é”ã—ãŸãŸã‚è‡ªå‹•çµ‚äº†ã—ã¾ã—ãŸ');
          } else {
            showPrompt('è¨ˆæ¸¬ãŒä¸Šé™æ™‚é–“ã«é”ã—ã¾ã—ãŸã€‚çµ‚äº†ã—ã¾ã™ã‹ï¼Ÿ', () => stopTrackingWithReason('ä¸Šé™æ™‚é–“ã§çµ‚äº†'), () => { });
          }
        }, Number(config.maxSessionMin) * 60000);
      }
    }
    function stopTracking() {
      touch();
      const active = activeByLine[currentLine];
      if (!active) return;
      const log = { id: uuid(), task: active.task, startedAt: active.startedAt, endedAt: Date.now() };
      appendLog(currentLine, log);
      activeByLine[currentLine] = null;
      fab.classList.remove('tracking'); fab.textContent = 'START';
      renderStatus();
      showUndo({ type: 'stop', line: currentLine, log });
      resetMaxTimer(currentLine);
    }
    function stopTrackingWithReason(msg) {
      const active = activeByLine[currentLine];
      if (!active) return;
      const log = { id: uuid(), task: active.task, startedAt: active.startedAt, endedAt: Date.now(), reason: msg };
      appendLog(currentLine, log);
      activeByLine[currentLine] = null;
      fab.classList.remove('tracking'); fab.textContent = 'START';
      renderStatus();
      showUndo({ type: 'stop', line: currentLine, log });
      resetMaxTimer(currentLine);
    }
    function resetMaxTimer(line) { if (maxTimerByLine[line]) { clearTimeout(maxTimerByLine[line]); maxTimerByLine[line] = null; } }

    /* ====== Undo (3s) ====== */
    function showUndo(info) {
      lastUndo = info;
      snackText.textContent = info.type === 'stop' ? 'çµ‚äº†ã‚’å–ã‚Šæ¶ˆã—ã¾ã™ã‹ï¼Ÿ' : 'å‰ã‚¿ã‚¹ã‚¯ã®è‡ªå‹•çµ‚äº†ã‚’å–ã‚Šæ¶ˆã—ã¾ã™ã‹ï¼Ÿ';
      snackbar.classList.remove('hidden');
      clearTimeout(undoTimer);
      undoTimer = setTimeout(() => snackbar.classList.add('hidden'), 3000);
    }
    undoBtn.addEventListener('click', () => {
      if (!lastUndo) return;
      const { type, line, log } = lastUndo;
      const arr = getLogs(line);
      const idx = arr.findIndex(x => x.id === log.id);
      if (idx >= 0) { arr.splice(idx, 1); saveLogs(line, arr); }
      // å¾©å¸°
      activeByLine[line] = { task: log.task, startedAt: log.startedAt };
      if (line === currentLine) { fab.classList.add('tracking'); fab.textContent = log.task; }
      renderStatus();
      snackbar.classList.add('hidden'); clearTimeout(undoTimer); lastUndo = null;
    });

    /* ====== Promptï¼ˆä¼‘æ†©å€™è£œï¼ä¸Šé™ç¢ºèªï¼‰ ====== */
    function showPrompt(text, onOk, onCancel) {
      promptText.textContent = text;
      promptModal.classList.add('open');
      document.body.classList.add('modal-open');
      const ok = () => { promptModal.classList.remove('open'); document.body.classList.remove('modal-open'); onOk?.(); idlePromptShown = false; };
      const cancel = () => { promptModal.classList.remove('open'); document.body.classList.remove('modal-open'); onCancel?.(); idlePromptShown = false; };
      promptOk.onclick = ok;
      promptCancel.onclick = cancel;
    }

    /* ====== ç„¡æ“ä½œï¼ˆIdleï¼‰æ¤œçŸ¥ â†’ ä¼‘æ†©å€™è£œ ====== */
    function touch() { lastInteraction = Date.now(); }
    ['click', 'mousemove', 'keydown', 'touchstart', 'touchmove'].forEach(ev => {
      document.addEventListener(ev, touch, { passive: true });
    });
    setInterval(() => {
      const a = activeByLine[currentLine];
      if (!a) return; // è¨ˆæ¸¬ä¸­ã®ã¿å¯¾è±¡
      const idleMs = Date.now() - lastInteraction;
      const limit = Number(config.idleRestMin || 0) * 60000;
      if (limit > 0 && idleMs >= limit && !idlePromptShown) {
        idlePromptShown = true;
        showPrompt(`ç„¡æ“ä½œãŒ${Math.round(limit / 60000)}åˆ†ç¶šã„ã¦ã„ã¾ã™ã€‚ä¼‘æ†©ã«ã—ã¾ã™ã‹ï¼Ÿ`, () => {
          // ç¾åœ¨ã‚¿ã‚¹ã‚¯ã‚’çµ‚äº† â†’ ä¼‘æ†©é–‹å§‹
          const prev = activeByLine[currentLine];
          if (prev) {
            const log = { id: uuid(), task: prev.task, startedAt: prev.startedAt, endedAt: Date.now(), reason: 'ç„¡æ“ä½œä¼‘æ†©' };
            appendLog(currentLine, log);
          }
          activeByLine[currentLine] = { task: 'ä¼‘æ†©', startedAt: Date.now() };
          fab.classList.add('tracking'); fab.textContent = 'ä¼‘æ†©';
          renderStatus();
          resetMaxTimer(currentLine);
        }, () => { /* ã‚­ãƒ£ãƒ³ã‚»ãƒ« */ });
      }
    }, 30000); // 30ç§’ã”ã¨ã«ç¢ºèª

    /* ====== Events ====== */
    document.querySelector('.wrap').addEventListener('contextmenu', (e) => { e.preventDefault(); toggleLineRing(true); });
    document.addEventListener('click', (e) => {
      if (lineRing.classList.contains('open')) {
        const within = lineRing.contains(e.target);
        const isRightClick = e.button === 2;
        if (!within && !isRightClick) toggleLineRing(false);
      }
    });
    fab.addEventListener('click', () => {
      // è¨ˆæ¸¬ä¸­ã¯çµ‚äº†
      if (activeByLine[currentLine]) { stopTracking(); return; }
      // Idleæ™‚ï¼šè¨­å®šã©ãŠã‚Šã®å‹•ä½œ
      const act = String(config.centerIdleAction || 'resume');
      if (act === 'resume') {
        const last = lastEndedByLine[currentLine];
        const limitMs = Number(config.quickResumeMin || 10) * 60000;
        if (last && (Date.now() - last.endedAt) <= limitMs) { startTracking(last.task); }
      } else if (act === 'openLineRing') {
        toggleLineRing(true);
      } else if (act === 'startDefault') {
        const def = (config.lines[currentLine] || defaults.lines[currentLine]).categories[0];
        if (def) startTracking(def);
      } // noneï¼šä½•ã‚‚ã—ãªã„
    });
    document.addEventListener('keydown', (e) => {
      const map = {
        Digit1: 'A', Digit2: 'B', Digit3: 'C', Digit4: 'D', Digit5: 'E',
        Numpad1: 'A', Numpad2: 'B', Numpad3: 'C', Numpad4: 'D', Numpad5: 'E'
      };
      if (map[e.code]) { setLine(map[e.code]); return; }
      if (e.code === 'Space') { e.preventDefault(); if (activeByLine[currentLine]) stopTracking(); }
      if (e.code === 'Escape') {
        toggleLineRing(false);
        // ã™ã¹ã¦ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        closeSettingsModal();
        closeLog();
        promptModal.classList.remove('open');
        document.body.classList.remove('modal-open');
      }
    });

    /* ====== Fullscreen Log ====== */
    openLogFullscreenBtn.addEventListener('click', () => openLog());
    logCloseBtn.addEventListener('click', () => closeLog());
    logSearchInput.addEventListener('input', () => renderLogFullscreen(logSearchInput.value.trim()));
    function openLog() { logModal.classList.add('open'); document.body.classList.add('modal-open'); renderLogFullscreen(''); }
    function closeLog() { logModal.classList.remove('open'); document.body.classList.remove('modal-open'); }
    function renderLogFullscreen(q) {
      let all = [];
      LINES.forEach(line => {
        const conf = config.lines[line] || defaults.lines[line];
        const name = conf.name;
        all = all.concat(getLogs(line).map(l => ({ ...l, line, lineName: name })));
      });
      all.sort((x, y) => (y.endedAt || 0) - (x.endedAt || 0));
      const kw = (q || '').toLowerCase();
      const filt = kw ? all.filter(l => (String(l.task).toLowerCase().includes(kw) || String(l.line).toLowerCase().includes(kw) || String(l.lineName).toLowerCase().includes(kw))) : all;
      logBody.innerHTML = '';
      filt.slice(0, 1000).forEach(l => {
        const row = document.createElement('div'); row.className = 'logRow';
        row.innerHTML = `
      <div><span class="logBadge ${l.line}" style="background:${LINE_COLOR[l.line]}">${l.line}</span> ${escapeHtml(l.lineName || '')}</div>
      <div>${escapeHtml(l.task)}</div>
      <div>${fmt(l.startedAt)} â†’ ${fmt(l.endedAt)}ï¼ˆ${dur(l.startedAt, l.endedAt)}ï¼‰${l.reason ? 'ï½œ' + escapeHtml(l.reason) : ''}</div>`;
        logBody.appendChild(row);
      });
    }
    function escapeHtml(s) { return String(s).replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m])); }

    /* ====== CSV Exportï¼ˆlineNameåˆ—ä»˜ãï¼‰ ====== */
    exportCsvBtn.addEventListener('click', () => {
      let all = []; LINES.forEach(line => {
        const conf = config.lines[line] || defaults.lines[line];
        const name = conf.name;
        all = all.concat(getLogs(line).map(l => ({ ...l, line, lineName: name })));
      });
      all.sort((a, b) => (a.startedAt || 0) - (b.startedAt || 0));
      const header = ['lineId', 'lineName', 'task', 'startedAt', 'endedAt', 'startedISO', 'endedISO', 'durationSec', 'reason'];
      const rows = [header.join(',')];
      all.forEach(l => {
        const durSec = Math.max(0, Math.round((l.endedAt - l.startedAt) / 1000));
        rows.push([
          l.line, csvEsc(l.lineName || ''), csvEsc(l.task), l.startedAt, l.endedAt,
          csvEsc(new Date(l.startedAt).toISOString()),
          csvEsc(new Date(l.endedAt).toISOString()),
          durSec, csvEsc(l.reason || '')
        ].join(','));
      });
      const csv = rows.join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const a = document.createElement('a'); const ts = new Date().toISOString().slice(0, 10).replace(/-/g, '');
      a.href = URL.createObjectURL(blob); a.download = `timelogs_all_${ts}.csv`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
    });
    function csvEsc(s) { const t = String(s ?? ''); return /[",\n]/.test(t) ? `"${t.replace(/"/g, '""')}"` : t; }

    /* ====== Settingsï¼ˆæ­£å¼åç§°ï¼‹æ“ä½œé …ç›®ï¼‰ ====== */
    openSettingsBtn.addEventListener('click', () => openSettings());
    closeSettingsBtn.addEventListener('click', () => closeSettingsModal());
    closeSettingsXBtn.addEventListener('click', () => closeSettingsModal());
    settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) closeSettingsModal(); }); // èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹

    resetDefaultBtn.addEventListener('click', () => {
      config = structuredClone(defaults);
      saveConfig(config);
      categories = (config.lines[currentLine] || defaults.lines[currentLine]).categories;
      drawInnerWheel();
      openSettings(); // å†æç”»
    });
    exportJsonBtn.addEventListener('click', () => {
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'wheel_config.json';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
    });
    importJsonBtn.addEventListener('click', () => {
      const inp = document.createElement('input'); inp.type = 'file'; inp.accept = 'application/json';
      inp.onchange = () => {
        const file = inp.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const obj = JSON.parse(reader.result);
            // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼šlines.A..E.nameï¼ˆæ–‡å­—åˆ—ï¼‰ã€categoriesï¼ˆé…åˆ—ï¼‰
            const ok = LINES.every(k => {
              const ln = obj?.lines?.[k];
              return ln && typeof ln.name === 'string' && Array.isArray(ln.categories) && ln.categories.length >= 1 && ln.categories.length <= 12;
            });
            if (!ok) { alert('ä¸æ­£ãªè¨­å®šJSONï¼ˆlines.A..E ã® name ã¨ categories ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼‰'); return; }
            config = {
              ...defaults,
              ...obj,
              idleRestMin: Number(obj.idleRestMin ?? defaults.idleRestMin),
              maxSessionMin: Number(obj.maxSessionMin ?? defaults.maxSessionMin),
              maxSessionAction: String(obj.maxSessionAction ?? defaults.maxSessionAction),
              centerIdleAction: String(obj.centerIdleAction ?? defaults.centerIdleAction),
              quickResumeMin: Number(obj.quickResumeMin ?? defaults.quickResumeMin)
            };
            saveConfig(config);
            categories = (config.lines[currentLine] || defaults.lines[currentLine]).categories;
            drawInnerWheel(); openSettings();
          } catch (e) { alert('JSONã®èª­ã¿è¾¼ã¿ã«å¤±æ•—'); }
        };
        reader.readAsText(file);
      };
      inp.click();
    });
    saveSettingsBtn.addEventListener('click', () => {
      const newCfg = structuredClone(config);
      // è‡ªå‹•ãƒ«ãƒ¼ãƒ«
      newCfg.idleRestMin = Number(idleRestMinInput.value || defaults.idleRestMin);
      newCfg.maxSessionMin = Number(maxSessionMinInput.value || defaults.maxSessionMin);
      newCfg.maxSessionAction = String(maxSessionActionInput.value || defaults.maxSessionAction);
      newCfg.centerIdleAction = String(centerIdleActionInput.value || defaults.centerIdleAction);
      newCfg.quickResumeMin = Number(quickResumeMinInput.value || defaults.quickResumeMin);
      // ãƒ©ã‚¤ãƒ³åï¼†ã‚«ãƒ†ã‚´ãƒª
      LINES.forEach(line => {
        const nameInput = document.getElementById(`lineName_${line}`);
        const ta = document.getElementById(`ta_${line}`);
        const name = nameInput.value.trim() || `LINE ${line}`;
        const arr = ta.value.split('\n').map(s => s.trim()).filter(s => s.length > 0);
        newCfg.lines[line] = { name, categories: arr };
      });
      config = newCfg; saveConfig(config);
      categories = (config.lines[currentLine] || defaults.lines[currentLine]).categories;
      drawInnerWheel(); renderStatus();
      closeSettingsModal();
    });

    function openSettings() {
      editorsEl.innerHTML = '';
      LINES.forEach(line => {
        const conf = config.lines[line] || defaults.lines[line];
        const div = document.createElement('div'); div.className = 'lineEditor';
        const h = document.createElement('h3'); h.innerHTML = `<span class="badge ${line}">${line}</span> æ­£å¼åç§°`;
        const nameInput = document.createElement('input'); nameInput.id = `lineName_${line}`; nameInput.className = 'lineNameInput'; nameInput.value = conf.name || `LINE ${line}`;
        const p = document.createElement('p'); p.style.margin = '6px 0'; p.textContent = 'æ“ä½œé …ç›®ï¼ˆ1è¡Œ1é …ç›®ï½œæ¨å¥¨ï¼š6ã€œ8ï¼‰';
        const ta = document.createElement('textarea'); ta.id = `ta_${line}`; ta.value = (conf.categories || []).join('\n');
        div.appendChild(h); div.appendChild(nameInput); div.appendChild(p); div.appendChild(ta);
        editorsEl.appendChild(div);
      });
      // ãƒ«ãƒ¼ãƒ«ã®ç¾åœ¨å€¤
      idleRestMinInput.value = Number(config.idleRestMin ?? defaults.idleRestMin);
      maxSessionMinInput.value = Number(config.maxSessionMin ?? defaults.maxSessionMin);
      maxSessionActionInput.value = String(config.maxSessionAction ?? defaults.maxSessionAction);
      centerIdleActionInput.value = String(config.centerIdleAction ?? defaults.centerIdleAction);
      quickResumeMinInput.value = Number(config.quickResumeMin ?? defaults.quickResumeMin);
      settingsModal.classList.add('open');
      document.body.classList.add('modal-open');
    }
    function closeSettingsModal() {
      settingsModal.classList.remove('open');
      document.body.classList.remove('modal-open');
    }

    /* ====== Init ====== */
    function init() {
      renderStatus();
      drawInnerWheel();
      drawLineRing();
      setLine('A');
    }
    init();
  </script>
</body>

</html>